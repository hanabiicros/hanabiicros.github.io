{"pages":[{"title":"About Me","text":"帅斌/斌哥/icros 华南理工大学17级本科生 ACG文化爱好者 腿控、xi(啊呸) 休伯利安舰长 薇尔莉特守护者(｡･ω･｡)ﾉ♡ 伊卡洛斯老公(⁄ ⁄•⁄ω⁄•⁄ ⁄) … 学习 前端初学者 了解html\\css\\js 了解Vue 了解Git 了解webpack 了解SSM hai，后悔当初没有早点搞个博客，很多都是自己上网零散着看的，没有总结，有些已经忘了|･ω･｀) 联系方式 email:zjk0718@163.com","link":"/about/"}],"posts":[{"title":"Markdown基本语法","text":"初学markdown时踩过的坑… 前言 不得不承认，在写这篇文章前，我对markdown的使用仅仅停留在如何显示标题、链接、图片以及如何加代码块。 一开始我以为这点就够了，不过当我编辑关于页面时，我ku了。由于网上教程有些坑，加之官网的描述不甚详细，因此我决定结合我的亲身试验，对其进行总结 Markdown介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。(ps:摘自菜鸟教程)个人感觉菜鸟教程更新的不够及时 标题 标题有一级到六级之分，以’#’的数量区分。一个’#’是一级标题，两个’#’是二级标题，以此类推。不过这个说白了就是加粗、加大，html实现也挺容易的。 eg: ### 三级标题 三级标题#### 四级标题 四级标题 字体 斜体：将文字用一个*号包起来 加粗：将文字用两个*号包起来 斜体＆加粗：将文字用三个*号包起来 分隔线：用三个以上的’*‘、’-‘或’_’来建立一行分隔线 删除线：将文字用两个~号包起来 不过你也可以选择用html标签代替(那你还用啥子markdown喽) eg: *斜体*斜体 **加粗**加粗 ***斜体&amp;粗体***斜体&amp;粗体 ~~删除线~~删除线 分隔线 *** * * * **** 段落 缩进：在全角模式下用空格进行缩进 换行：行尾加上两个及以上的空格然后换行；或者直接硬换行，敲个回车键。若要中间空多行可以输入多个&lt;br/&gt; 引用 需要引用文字，可以在其前加&gt;即可，而且支持嵌套 eg: &gt;这是引用的内容 &gt;&gt;这是引用的内容的&apos;弟弟&apos; 这是引用的内容 这是引用的内容的’弟弟’ 图片 要插入图片，形式如下： ![alt](图片地址) ![alt](图片地址 &quot;title属性&quot;) 其中，’[]’中的alt填图片的说明文字，如”图1”之类的，”title属性”可加可不加，当鼠标hover时展示的信息 eg: ![图1](wlop01.jpg) 链接 插入链接，形式如下： [链接名称](链接地址)eg: [百度](https://www.baidu.com) 百度 列表 无序列表 在每个列表项之前加’+’、’-‘或’*‘即可，而且列表项与之前的符号之间必须有一个空格 eg: + 列表1 - 列表2 * 列表3 列表1 列表2 列表3 有序列表 列表项前用数字&amp;’.’表示 eg: 1. 列表1 2. 列表2 3. 列表3 列表1 列表2 列表3 列表嵌套 在子列表的每一项前添加四个空格即可 eg: 1.第一项 + 第一项嵌套的第一个元素 + 第一项嵌套的第二个元素 第一项 第一项嵌套的第一个元素 第一项嵌套的第二个元素 表格 表格用’|’来分隔不同的单元格，使用’-‘来分隔表头和其他行，而且’:-‘表示左对齐，’-:’表示右对齐，’:-:’表示居中对齐 eg: | 左对齐 | 右对齐 | 居中对齐 | | :--| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 额，应该是这个icrsus主题的设置，忽略了表格的竖线，不过也挺好看的 代码 单行代码 代码之间用反引号包起来eg： `int a = 10;` int a = 10; 代码块 代码之间用三个反引号包起来，且反引号独占一行eg: (```) code (```)1code 那两个小括号是为了防止其转译多加的，实际使用应去掉 写到这里，也就差不多了，markdown的基本使用都介绍了，我得去修改前几篇博客的样式了(ಥ_ಥ)​","link":"/archives/5d36ff15.html/"},{"title":"基于Hexo创建博客(基础篇)","text":"这只是个最基础的教程，参考了知乎上“洪卫”dl的文章——“Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)”。 其他各种自定义配置详见“大佬”的教程（｡ò ∀ ó｡） 安装Git Git作为目前世界上最先进的分布式版本控制系统，拥有强大的项目版本管理能力。(ps:不过我暂时还没去深入了解，(lll￢ω￢)) Windows直接到官网下载就行，Linux的话直接一行shell命令解决 1sudo apt-get install git 安装Node.js 因为’Hexo’是基于’Node.js’编写的，所以需要先安装’Node.js’以及包管理工具’npm’ 同样Windows到官网下载，无脑安装即可，Linux还是命令行安装 12sudo apt-get install nodejssudo apt-get install npm 安装Hexo 前两个工具安装完毕之后，就可以安装’Hexo’了。 先创建一个文件夹用于存放博客文件，我是放在’D:\\Study\\MyBlog’下。接着在该目录下右键点击’Git Bash Here’,打开’git’的控制台窗口。输入如下命令全局安装hexo脚手架： 1npm install -g hexo-cli 安装完成后，可以输入’hexo -v’检查是否安装成功 Hexo初始化自己的网站 在git控制台输入： 1hexo init BinBlog 初始化自己网站，其中’BinBlog’是我自己命名的博客网站名称，可随意命名 安装依赖项 进入刚创建的博客目录，安装依赖项。 12cd BinBlognpm i 安装完毕后，在响应的博客目录下，可以看到如下文件夹： -&apos;node_modules&apos;:依赖包 -&apos;public&apos;:存放生成的页面，包括html、css、js等 -&apos;scaffolds&apos;:生成文章的一些模板，比如草稿md、页面md以及文章md -&apos;source&apos;:存放你写的文章以及你需要自己添加的一些资源文件 -&apos;themes&apos;:主题文件，Hexo有多种主题，默认使用的是&apos;landscape&apos;主题 -&apos;_config.yml&apos;:博客的配置文件，其中可以配置网站的各种属性，之后再说预览默认博客页面 输入’hexo g’生成静态页面，然后输入’hexo s’打开本地服务器 12hexo ghexo s 服务器会开放4000端口，浏览器打开’localhost:4000/‘可以看到默认的博客页面。 emmmm，不得不说这个默认的页面感觉有点丑，不过不要紧，后续我会提供本网站所使用的主题icarus的教程。 Github上创建个人仓库 在如图1位置’New repository’，新建个人仓库 然后在’Repository name’字段处填自己的github账号名称+’github.io’，这样当部署到’yourname.github.io’网址时，才会识别到你的仓库，另外在初始化时附带上README。如图2所示 生成SSH并添加到Github 在git控制台输入如下命令 12git config --global user.name \"yourname\"git config --global user.email \"youremail\" 全局设置到指定的Git仓库。网上给的设置邮箱的命令是： 1git config --global At-Cost Domain Pricing - Domain Cost Club \"youremail\" 但是我输入之后提示错误信息… 接着创建’SSH’，学过信息安全的应该都知道。说白了就是通过公私钥匹配，将你的文件上传到’GitHub’上。 1ssh-keygen -t rsa -C \"youremail\" 然后一般在你的’C:\\Users\\xxx'目录下，会生成’.ssh’文件夹，里面有你的私钥和公钥。可能我之前生成过ssh，已经有了该目录，就不演示了。 接着将生成的公钥’id_rsa.pub’的内容复制到你的github上，如图3所示。 即在setting中的’SSH and GPG keys’中’New SSH key’，给其取个名字，然后将复制的公钥粘贴到此处。 在git控制台输入 1ssh -T git@github.com 若出现你的用户名，即配置成功 将hexo部署到GitHub上 接着我们就可以将hexo生成的网页托管到GitHub上。 修改’_config.yml’文件 打开博客根目录下的’_config.yml’配置文件，修改最后一行的配置： 1234deploy: type: git repository: https://github.com/hanabiicros/hanabiicros.github.io branch: master ‘repository’的位置填写自己的github地址即可。这样通过git命令上传的文件就会放到你的仓库中 安装deploy-git 需要先安装部署的命令，才能用’git d’上传到’GitHub’ 1npm install hexo-deployer-git --save 然后执行如下命令： 123hexo chexo ghexo d ‘hexo c’即清除命令，这个命令还是挺好用的，如果你遇到一般的小bug，那就’hexo c’然后再执行。’hexo g’即生成静态网页，’hexo d’部署文章。若提示’Deploy done:git’即操作成功。之后就能在’yourname.github.io’网站上看到你的博客。 写文章并发布 完成了上述基本步骤之后，你如果就用默认的主题的话，那么你就可以开始撰写你的第一个’纯文本’博客了。之所以说是’纯文本’，是因为还有许多hexo插件没有介绍。具体内容将放在下一篇进行具体说明。 现在你需要做的就是在博客的根目录下输入 1hexo new post \"arctile title\" 新建一篇文章，然后在博客根目录下的’source_posts’的目录下多了一个’xxx.md’的文件，这就是你刚刚创建的。接着就可以进入’vscode’中编辑’markdown’文件了。编写完后执行固定的这三个命令’hexo c’、’hexo g’、’hexo d’。你也可以在提交前先进行本地预览，输入 1hexo server 到这里一个最基本的博客就搭建完毕了。下一篇会对里面的具体配置内容进行相关介绍，并进行个性化定制！","link":"/archives/5ec59427.html/"},{"title":"PicGo+GitHub免费图床工具","text":"PicGo+GitHubGitee让你的md文档起飞 前言 我在前几篇博客中提到过，如何在markdown文件中插入图片。要么是按照markdown自己的方式，使用![]()的方式，要么使用Hexo提供的标签插件。但是他们的本质都是根据图片的path，从本地中取出。这种获取图片的方式存在一个问题，即当我们更换工作环境之后，我们除了要将md文档复制过去，还要连同本地图片一起附带过去。 虽然我们可以将图片一起上传到Github上，但是这种方式无法做到对图片的统一管理。因此图床这个工具就派上大用场。图床，即自动把本地图片转换成链接的一款工具。 这次我们介绍一款非常优秀的图床工具——PicGo，它支持微博、七牛云、腾讯云COS、又拍云、GitHub、阿里云OSS、SM.MS、Imgur等8种常用图床，功能强大、界面美观、简单易用。(不过有时会突然冒出一些无厘头的bug) 我使用的是PicGo+GitHub，若使用其他图床工具可自行探索。 更新：用了一段时间，发现GitHub图床不太行|ω・），上传速度慢，而且经常失败。后来改用了Gitee，这篇文档就当了解吧，而且Gitee图床和GitHub图床配置差不多 创建GitHub图床注册GitHub账号创建Repository 前两步比较简单，注意创建仓库时，用README初始化仓库 生成Token 点击个人头像中的”Settings”，选中个人设置中的最下面一个按钮”Developer settings” 然后点击”Personal access tokens”，选中”Generate new token”，生成新的令牌 然后选择repo权限，名称随意即可 (令牌生成后，只会出现一次，请将它复制下来并保存好) 配置PicGo安装PicGo 首先，你需要到GitHub上的PicGo项目中下载可执行文件。若是mac系统，选择dmg后缀的文件，若是window，选择exe后缀的文件。 GitHub上下载资源可能会遇到网页无法访问或下载速度过慢的问题，这时候我只能说一句：“迅雷是个好东西”(ಡωಡ) 安装了迅雷的同学，直接右键使用迅雷下载即可，速度非常快。 PicGo上配置GitHub图床 仓库名：按照”用户名/仓库名”的格式，比如我的用户名为”hanabiicros”，仓库名为”cdn” 分支名：填”master”即可 Token：中将刚刚创建的令牌粘贴在这里即可 存储路径：随意 自定义域名：按照”https://raw.githubusercontent.com/用户名/仓库名/master”的格式填写，记住一定要加master，不加master会导致生成的图片链接无法访问到 PicGo设置 在设置中，可以点开日志文件，用来查看报错信息；可以修改快捷键等。建议开启时间戳重命名，这样可以防止上传两张同名图片而导致上传失败。","link":"/archives/b29ed1f0.html/"},{"title":"基于Hexo创建博客(进阶篇)","text":"这是对基础篇的补充，方便了解Hexo，并对其进行个性化配置 Hexo基本配置_config.yml配置文件 该文件中是整个’Hexo’框架的配置文件，下面对其部分参数信息进行描述. Site1234567title: icrosの小窝subtitle: ''description: '帅斌的博客'keywords:author: Yaobin Zhanglanguage: zh-CNtimezone: '' -&apos;title&apos;：网站的标题 -&apos;subtitle&apos;：网站的副标题 -&apos;description&apos;：网站的描述，用于SEO -&apos;keywords&apos;：网站的关键词 -&apos;author&apos;：网站的作者 -&apos;language&apos;：网站所使用的语言，默认是en，你可以改为&apos;zh-CN&apos;简体中文 -&apos;timezone&apos;：网站的时区，默认使用你电脑的时区 URL1234567url: https://hanabiicros.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true trailing_html: true -&apos;url&apos;：网址，如果你的网站是放在子路径下，则将其设置为&apos;http://yoursite.com/child&apos; -&apos;root&apos;：网站的根目录 -&apos;permalink&apos;：文章的永久链接格式，即发布的文章在网站下生成的路径格式，默认是&apos;yoursite.com/year/month/day/title&apos; -&apos;pretty_urls&apos;：改写permalink的值来美化URL -&apos;pretty_urls.trailing_index&apos;：是否在永久链接中保留尾部的index.html -&apos;pretty_urls.trailing_html&apos;：是否在永久链接中保留尾部的.html Directory12345678source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: 主要配置了各个文件夹的存放位置，另外’skip_render’表示跳过指定文件的渲染，即你可以使用自己的样式，一般默认即可。 home page setting1234index_generator: path: '' per_page: 10 order_by: -date -&apos;index_generator.path&apos;：指明博客主页的根路径 -&apos;index_generator.per_page&apos;：每页显示的最多文章数 -&apos;index_generator.order_by&apos;：文章的排序方式 Extensions1theme: icarus -&apos;theme&apos;：当前主题名称 -&apos;theme_config&apos;：主题的配置文件，会覆盖主题目录下的&apos;_config.yml&apos;中的配置 -&apos;deploy&apos;：部署部分的设置 其他配置默认即可，详细信息可见官方文档 Hexo基本操作写作 ‘基础篇’中讲了用如下命令，新建一篇文章 1hexo new post 'title' 除了新建文章外，还可以新建页面’page’或者草稿’draft’ 12hexo new page 'title'hexo new draft 'title' 其中新建的页面’page’的’title’，和你在导航栏中自定义的路径’/title’相匹配的。即点击导航栏的’title’按钮，会定位到这个页面中。(ps:当初看官方文档的时候看到了这里，不过没仔细看，结果在’关于’页面卡了好久，不知道怎么加这个页面。han(lll￢ω￢)) Front-matter Front-matter是每个post中最上方以’—‘分割的区域，指定个别文件的变量 12345678910---title: 基于Hexo创建博客(进阶篇)date: 2020-03-26 22:08:31thumbnail: /images/wc01.jpgtoc: truetags: #标签 - Hexo - Blogcategories: 技术--- -&apos;title&apos;：标题 -&apos;date&apos;：建立日期 -&apos;updated&apos;：更新日期 -&apos;tags&apos;：标签，网站会根据每篇文章的标签进行归类 -&apos;categories&apos;：分类，同样网站会根据每篇文章所属分类进行归类 -&apos;comments&apos;：开启文章的评论功能，不加默认开启 -&apos;permalink&apos;：覆盖文章的网址 另外’thumbnail’和’toc’是’icarus’主题特有的。 资源插入插入图片 在Hexo 2之前，许多人是推荐安装’hexo-asset-image’，该插件貌似是解决了因常规的md语法和相对路径引用资源的方式造成在存档页和主页显示不正确的问题(ps:因为我是一上手就直接体验icarus主题，因而没遇到这个问题，况且我还是最新版的Hexo呢) 1npm install https://github.com/CodeFalling/hexo-asset-image --save 然后在博客根目录下的’_config.yml’文件中将’post_asset_folder’属性设置为true，这样在每次创建新的文章时，他会自动在同目录下创建一个同名的文件夹，该文件夹用于存放与文章相关的资源。 接着用传统的md形式就能实现图片的插入 1![title](xxx.jpg/png) 但是我在官方提供的插件库中，并未找到’hexo-asset-image’，只有’hexo-asset’，不过提供的功能大致是一样的。 标签插件 除了上述方法，在Hexo 3中，官方提供了名为’标签插件’的东东 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} 像这样也可以实现路径、图片、链接的插入，当然这个功能是很强大的，官方提供了’引用块’、’代码块’、’Image’、’Youtube’等的插入方式。对于码农而言，主要用到的还是代码块的插入。一般使用，只需指明使用的语言’lang:’即可，而且它默认显示行号。 123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} 还有一种就是用反引号的形式(格式问题，不能换行只能放在一行，实际使用将代码和第二个反引号换行) 1``` [language] [title] [url] [link text] code snippet``` Hexo插件hexo-abbrlink 由于Hexo在生成博客文章链接时，默认是按照年/月/日/标题的格式，这样生成的链接太过冗长，虽然可以在_config.yml中修改”permalink”的格式，但是这样还是无法保证链接的唯一性，而且可能会造成链接的格式混乱。 而hexo-abbrlink插件可以生成唯一文章链接，而且配置十分简单。先安装该插件，在博客根目录，右键”Git Bush Here”，打开git控制台，然后输入如下命令： 1npm install hexo-abbrlink --save 接着在博客根目录下的_config.yml文件中，设置如下： 1234permalink: archives/:abbrlink.html/ #archives的位置可以随意命名，或archives/:abbrlink/abbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex hexo-generator-feed 首先，我们需要了解什么是RSS，RSS指Really Simple Syndication(真正简易联合)。RSS是我们有能力聚合网站的内容，它定义了非常简单的方法来共享和查看标题和内容。RSS文件可被自动更新，且允许为不同的网站进行视图的个性化。 之所以使用RSS，是为了让订阅RSS的用户不必每日来您的网站检查更新，他可以使用RSS聚合器来检查更新。 先安装hexo-generator-feed，git控制台输入 1npm install hexo-generator-feed --save 然后在_config.yml文件中在Extension位置，添加如下内容： 123456789theme: icarus#RSS订阅plugin: - hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 设置完毕后，你的RSS链接就是域名/atom.xml。一般RSS功能在页面上的标志是”wifi信号” hexo-lazyload-image 由于图片等静态资源的加载，需要花费较多的时间，因此我们需要优化网站图片加载的速度。图片懒加载是一种常用的方法。hexo-lazyload-image插件会将博客中img标签的src属性替换为一个loading image，把真实的图片地址放在data-origin属性下面，然后当加载到该图片时，它会用一段js将data-origin的内容替换为src，达到懒加载的目的。 首先，进入博客根目录下安装该插件： 1npm install hexo-lazyload-image --save 然后在_config.yml配置文件中，添加如下配置： 1234lazyload: enable: true onlypost: false #若为true,则只有在post和page中会支持懒加载 loadingImg: # eg ./images/loading.gif #如果不填，使用默认的加载图片，若想自定义，可将相应图片放到文件夹中，并填写相应的路径 eg: valine评论插件 由于我使用的icarus主题已经集成了valine评论插件功能，因此只需要在主题文件夹下的_config.yml文件中添加上valine插件的app_id和app_key即可。获取方法，登录LeanCloud官网，注册LeanCloud账号。 然后创建应用，选择开发版，名称随意，如下： 接着在设置-应用Keys中就可以看到你的AppID和AppKey，如下： 若想管理评论数据，可以在存储-结构化数据-Comment中设置：","link":"/archives/413d9fe2.html/"},{"title":"前端面试汇总——js","text":"重中之重的js篇 document load和document ready的区别 1. load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响 2. $(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行。在原生的js中不包括ready()这个方法，只有load方法也就是onload事件 js中的基本数据类型和引用数据类型基本类型(Undefined/Null/Boolean/Number/String/Symbol)：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。它们是直接按值存放的，可以直接访问引用类型(Object/Array/RegExp/Date/Function)：存放在堆内存中的对象；每个空间大小不一样，根据情况进行特定的分配。当我们需要访问引用数据类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。 JavaSript中如何检测一个变量是一个String类型 typeof:1typeof('123') === \"strig\" //true constructor:1'123'.constructor === String Object.prototype.toString.call()1Object.prototype.toString.call('123') === '[object String]' 请用js去除字符串空格 1. replace正则匹配方法eg 123456789101112131415var str = \" 6 6 \";var str_1 = str.replace(/\\s*/g, \"\"); // \\s表示空格，g表示全局匹配，*表示匹配零个或多个console.log(str_1); //去除字符串所有空格var str = \" 6 6 \";var str_1 = str.replace(/^\\s*|\\s*$/g, \"\");console.log(str_1); //6 6//输出左右侧均无空格var str = \" 6 6 \";var str_1 = str.replace(/^\\s*/g, \"\");console.log(str_1); //6 6 //输出右侧有空格左侧无空格var str = \" 6 6 \";var str_1 = str.replace(/\\s*$/g, \"\");console.log(str_1); // 6 6//输出左侧有空格右侧无空格 2. str.trim()方法 trim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串 3. JQ 方法：$.trim(str)方法 js是一门怎样的语言，有什么特点 脚本语言。JavaScript 是一种解释型的脚本语言,C、C++等语言先编译后执行,而 JavaScript 是在程序的运行过程中逐行进行解释。特点： 1. 基于对象。JavaScript 是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。 2. 简单。JavaScript 语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于 Java 基本语句和控制的脚本语言,其设计简单紧凑。 3. 动态性。JavaScript 是一种采用事件驱动的脚本语言,它不需要经过 Web 服务器就可以对用户的输入做出响应。 4. 跨平台性。JavaScript 脚本语言不依赖于操作系统,仅需要浏览器的支持。 == 和 === 的不同 == 是抽象相等运算符，而 === 是严格相等运算符。==运算符是在进行必要的类型转换后，再比较。=== 运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回false。使用== 时，可能发生一些特别的事情。eg 1234561 == \"1\"; // true1 == [1]; // true1 == true; // true0 == \"\"; // true0 == \"0\"; // true0 == false; // true 如何添加、移除、移动、复制、创建和查找节点 创建新节点 createDocumentFragment() //创建一个 DOM 片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的 Name 属性的值 getElementById() //通过元素 Id，唯一性 事件委托是什么 利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行 那什么样的事件可以用事件委托，什么样的事件不可以用呢？ 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没有冒泡的特性，自然就不用事件委托了。 为什么要用事件委托 1. 提高性能eg:12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;凤梨&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// gooddocument.querySelector('ul').onclick = (event) =&gt; { let target = event.target if (target.nodeName === 'li') { console.log(target.innerHTML) }}// baddocument.querySelectorAll('li').forEach((e) =&gt; { e.onclick = function() { console.log(this.innerHTML) }})&lt;/script&gt; 2. 新添加的元素还会有之前的事件 事件冒泡与事件委托的对比 事件冒泡：box 内部无论是什么元素，点击后都会触发 box 的点击事件 事件委托：可以对 box 内部的元素进行筛选 事件委托怎么取索引？1234567891011121314151617181920212223&lt;ul id=\"ul\"&gt; &lt;li&gt;aaaaaaaa&lt;/li&gt; &lt;li&gt;事件委托了 点击当前，如何获取 这个点击的下标&lt;/li&gt; &lt;li&gt;cccccccc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function () { var oUl = document.getElementById(\"ul\"); var aLi = oUl.getElementsByTagName(\"li\"); oUl.onclick = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == \"li\") { var that = target; var index; for (var i = 0; i &lt; aLi.length; i++) if (aLi[i] === target) index = i; if (index &gt;= 0) alert('我的下标是第' + index + '个'); target.style.background = \"red\"; } } }&lt;/script&gt; require与import的区别 两者的加载方式不同、规范不同 两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载12345678require('./a')(); // a 模块是一个函数，立即执行 a 模块函数var data = require('./a').data; // a 模块导出的是一个对象var a = require('./a')[0]; // a 模块导出的是一个数组 ======&gt; 哪都行import $ from 'jquery';import * as _ from '_';import {a,b,c} from './a';import {default as alias, a as a_a, b, c} from './a'; ======&gt;用在开头 规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范 require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化；import 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。 javascript对象的几种创建方式 Object构造函数创建123var Person = new Object();Person.name = \"Nike\";Person.age = 29; 这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。 使用对象字面量表示法12345var Person = {}; //相当于 var Person = new Object();var Person = {4name: 'Nike';4age: 29;} 对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同 在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。3. 使用工厂模式创建对象 123456789101112function createPerson(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() { alert(this.name); }; return o;}var person1 = createPerson(\"Nike\", 29, \"teacher\");var person2 = createPerson(\"Arvin\", 20, \"student\"); 在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式4. 使用构造函数创建对象 12345678910function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name); };}var person1 = new Person(\"Nike\", 29, \"teacher\");var person2 = new Person(\"Arvin\", 20, \"student\"); 对比工厂模式，我们可以发现以下区别： 1. 没有显示地创建对象 2. 直接将属性和方法赋给了 this 对象 3. 没有 return 语句 4. 终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测 1234alert(person1 instanceof Object); //turealert(person1 instanceof Person); //turealert(person2 instanceof Object); //turealert(person2 instanceof Object); //ture 同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。那么构造函数确实挺好用的，但是它也有它的缺点：就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法5. 原型创建对象模式 123456789function Person() {}Person.prototype.name = \"Nike\";Person.prototype.age = 20;Person.prototype.jbo = \"teacher\";Person.prototype.sayName = function() { alert(this.name);};var person1 = new Person();person1.sayName(); 使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。eg: 123456789101112function Person() {}Person.prototype.name = \"Nike\";Person.prototype.age = 20;Person.prototype.jbo = \"teacher\";Person.prototype.sayName = function() { alert(this.name);};var person1 = new Person();var person2 = new Person();person1.name = \"Greg\";alert(person1.name); //'Greg' --来自实例alert(person2.name); //'Nike' --来自原型 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性6. 组合使用构造函数模式和原型模式 123456789101112function Person(name, age, job) {4this.name = name;4this.age = age;4this.job = job;}Person.prototype = {4constructor: Person, //constructor属性返回对此创建对象的函数的引用4sayName: function() {44alert(this.name);4};}var person1 = new Person('Nike', 20, 'teacher'); javascript继承的方式和优缺点 原型链继承缺点： 引用类型的属性被所有实例共享 在创建 Child 的实例时，不能向 Parent 传参 借用构造函数(经典继承)优点： 避免了引用类型的属性被所有实例共享 可以在 Child 中向 Parent 传参缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 组合继承优点： 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 原型式继承缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 寄生式继承缺点： 跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承优点： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。 与此同时，原型链还能保持不变； 因此，还能够正常使用 instanceof 和 isPrototypeOf。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式 什么是原型链 通过一个对象的proto可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的proto，最后找到了我们的 Object.prototype,从实例的原型对象开始一直到 Object.prototype 就是我们的原型链eg: 复杂数据类型如何转变为字符串 首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值， 如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法， 如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值， 如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。123456789101112131415161718192021222324252627282930313233341;var obj = { valueOf: function() { return 1; }};console.log(obj + \"\"); //'1'2;var obj = { valueOf: function() { return [1, 2]; }};console.log(obj + \"\"); //'[object Object]';3;var obj = { valueOf: function() { return [1, 2]; }, toString: function() { return 1; }};console.log(obj + \"\"); //'1';4;var obj = { valueOf: function() { return [1, 2]; }, toString: function() { return [1, 2, 3]; }};console.log(obj + \"\"); // 报错 Uncaught TypeError: Cannot convert object to primitive value javascript 的 typeof 返回哪些数据类型 7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6) 在css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理? dns 缓存，cdn 缓存，浏览器缓存，服务器缓存。 列举 3 种强制类型转换和 2 种隐式类型转换 强制（parseInt,parseFloat,Number）、隐式（+ -） 你对闭包的理解？优缺点？概念：闭包就是能够读取其他函数内部变量的函数。三大特性： 1. 函数嵌套函数。 2. 函数内部可以引用外部的参数和变量。 3. 参数和变量不会被垃圾回收机制回收。优点： 1. 希望一个变量长期存储在内存中。 2. 避免全局变量的污染。 3. 私有成员的存在。缺点： 1. 常驻内存，增加内存使用量。 2. 使用不当会很容易造成内存泄露。eg: 12345678910111213141516function outer() { var name = \"jack\"; function inner() { console.log(name); } return inner;}outer()(); // jackfunction sayHi(name) { return () =&gt; { console.log(`Hi! ${name}`); };}const test = sayHi(\"xiaoming\");test(); // Hi! xiaoming 虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。 但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。 如何判断 NaN isNaN()方法 new 一个对象的过程中发生了什么1234567// 1. 创建空对象；var obj = {};// 2. 设置新对象的 constructor 属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的 prototype 对象；obj.__proto__ = ClassA.prototype;// 3. 使用新对象调用函数，函数中的 this 被指向新实例对象：ClassA.call(obj); //{}.构造函数();// 4. 如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接返回该对象。 for in 和 for of1. for in 一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行 不建议使用 for in 遍历数组，因为输出的顺序是不固定的 如果迭代的对象的变量值是 null 或者 undefined, for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是 null 或者 undefined 2. for of for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 1234567891011121314151617var s = { a: 1, b: 2, c: 3};var s1 = Object.create(s);// 该方法创建一个新对象，使用现有的对象来提供新创建的对象的_proto_；for (var prop in s1) { console.log(prop); //a b c console.log(s1[prop]); //1 2 3}for (let prop of s1) { console.log(prop); //报错如下 Uncaught TypeError: s1 is not iterable}for (let prop of Object.keys(s1)) { //object.keys返回一个表示给定对象的所有可枚举属性的字符串数组 console.log(prop); // a b c console.log(s1[prop]); //1 2 3} 如何判断 JS 变量的一个类型（至少三种方式） typeof(判断引用类型时不准确，返回值只有object/function) instanceof(判断一个实例是否属于某种类型) constructor(对象才拥有的，从一个对象指向一个函数，含义是指向该对象的构造函数。所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数) + prototype(函数所独有的，含义是函数的原型对象，也就是这个函数所创建的实例的原型对象，作用是包含可以由特定类型的所有实例共享的属性和方法) for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别? 1. for in 会遍历自身及原型链上的可枚举属性 2. Object.keys 会将对象自身的可枚举属性的 key 输出 3. Object.getOwnPropertyNames 会将自身所有的属性的 key 输出eg: 12345678910111213141516171819202122232425262728293031323334353637383940414243var parent = Object.create(Object.prototype, { a: { value: 123, writable: true, enumerable: true, configurable: true }});// parent继承自Object.prototype，有一个可枚举的属性a（enumerable:true）。var child = Object.create(parent, { b: { value: 2, writable: true, enumerable: true, configurable: true }, c: { value: 3, writable: true, enumerable: false, configurable: true }});//child 继承自 parent ，b可枚举，c不可枚举//for infor (var key in child) { console.log(key);}// b// a// for in 会遍历自身及原型链上的可枚举属性//Object.keysconsole.log(Object.keys(child));// [\"b\"]// Object.keys 会将对象自身的可枚举属性的key输出//Object.getOwnPropertyNamesconsole.log(Object.getOwnPropertyNames(child));// [\"b\",\"c\"]// 会将自身所有的属性的key输出 iframe 跨域通信和不跨域通信不跨域通信主页面 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe name=\"myIframe\" id=\"iframe\" class=\"\" src=\"flexible.html\" width=\"500px\" height=\"500px\" &gt; &lt;/iframe&gt; &lt;/body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; function fullscreen() { alert(1111); } &lt;/script&gt;&lt;/html&gt; 子页面 flexible.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是子页面 &lt;/body&gt; &lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; // window.parent.fullScreens() function showalert() { alert(222); } &lt;/script&gt;&lt;/html&gt; 主页面调取子页面的showalert方法1myIframe.window.showalert(); 子页面调用主页面的fullscreen方法1window.parent.fullScreens(); js 在 iframe 子页面获取父页面元素1window.parent.document.getElementById(\"元素id\"); js 在父页面获取 iframe 子页面元素代码如下1window.frames[\"iframe_ID\"].document.getElementById(\"元素id\"); 跨域通信使用postMessage 子页面 1window.parent.postMessage(\"hello\", \"http://127.0.0.1:8089\"); 父页面接收 123window.addEventListener(\"message\", function(event) { alert(123);});","link":"/archives/aaea6312.html/"},{"title":"前端面试题汇总——HTML篇","text":"汇集了各个大佬的成果～(￣▽￣～)~ 前言 最近许多大厂都开启了暑期实习生招聘，看着大佬们一个个offer拿到手软，真想扇自己两巴掌。因此菜菜的我决定对面试题进行汇总，并且对自己的不足之处进行巩固，有备无患嘛。(主要来源：https://github.com/yisainan/web-interview/) 简述对HTML语义化的理解 1. 用正确的标签做正确的事情 2. HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式CSS情况下也以一种文档格式显示，并且容易阅读 3. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO 4. 使阅读网页源码的人能更容易将网站分块，便于阅读、维护以及理解 label标签作用以及使用方法 1. label标签用来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上 2. 使用方法：一种是id绑定，一种是嵌套eg: 1234&lt;label for=\"Name\"&gt;Number:&lt;/label&gt;&lt;input type=\"text\" name=\"Name\" id=\"Name\"&gt;&lt;label&gt;Date:&lt;input type=\"text\" name=\"B\"/&gt;&lt;/label&gt; iframe框架有哪些优缺点优点： 1. iframe能够原封不动的把嵌入的网页展示出来 2. 如果有多个网页引用iframe，那么只需修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷 3. 网页如果为了统一风格，header和footer都一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性 4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe解决 缺点： 1. 框架结构中出现各种滚动条 2. iframe会阻塞主页面的Onload事件，拖慢网页加载 3. 搜索引擎的检索程序无法解读这种页面，不利于SEO 4. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 HTML与XHTML有什么区别，推荐哪个 推荐使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下： 1. XHTML中所有的标签必须闭合 2. XHTML所有标签都必须使用小写 3. 所有的XML标记都必须合理嵌套 4. 所有的参数值都必须用引号””括起来 5. 把所有&lt;和&amp;特殊符号用编码表示 6. 给所有属性赋值 7. 不要在注释内容中使用”–” 8. 图片必须使用说明文字 ps:HTML元素以开始标签起始，以结束标签终止 HTML5的form如何关闭自动填充功能 将不想要自动完成的form或input设置为autocomplete=off title与h1、b与strong、i与em的区别 1. title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，SEO权重高于h1；h1概括的是文章的主题，一个页面最好只用一个h1 2. b是为了加粗而加粗，strong是为了标明重点而加粗 3. i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i重视的多 描述下SEO中的TDK 在SEO中，所谓的TDK就是title(标题标签)、description(描述标签)、keywords(关键词标签)这三个标签 HTML文件头中的DOCTYPE的作用 1. 告知浏览器，文档使用的是哪种HTML或XHTML规范 2. 告诉浏览器按照何种规范(DTD)解析页面，若没有DOCTYPE声明，那么浏览器将按照自己的方式解析渲染页面 简述一下src和href区别 src用于引用资源，替换当前元素；href用于在当前文档和引用资源之间确立联系。 href: href标识超文本引用，用在link和a等标签上，是在当前元素和引用资源之间建立联系。若在文档中添加href，浏览器会识别该文档为CSS文件，就会并行下载资源并且不会停止对当前文档的处理。因此建议使用link方式加载CSS，而不是使用@import方式 src: src表示引用资源，替换当前元素，用在img,script,iframe上。当浏览器解析到src，会暂停其他资源的下载和处理(图片不会)，直到将该资源加载、编译、执行完毕，类似于将所有资源引用到当前内容。因此建议把js脚本放在底部而不是头部 严格模式与混杂模式 严格模式：以浏览器支持的最高标准运行 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为 对WEB标准以及W3C的理解 WEB标准简单来说可以分为结构、表现和行为。其中结构主要由HTML标签组成。表现即指CSS样式表。行为指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要由js组成 WEB标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使得这三者的界限并不那么清晰 W3C对WEB标准提出了规范化的要求，也就是在实际编程中的一些代码规范。包含如下几点： 1. 对于结构要求： 1. 标签字母要小写 2. 标签要闭合 3. 标签不允许随意嵌套 2. 对于CSS和js要求： 1. 尽量使用外联CSS样式表和js脚本。将结构、表现和行为分为三块。同时提高页面渲染速度，提高用户体验。 2. 样式尽量少用行间样式表，使结构和表现分离，标签的id和class等属性命名要做到见文知意，标签越少，加载越快，代码维护简单，便于改版 3. 不需要变动页面内容，便可提供打印版本而不需要复制内容 列举IE与其他浏览器不一样的特性 1. IE的排版引擎是Trident 2. Trident内核曾经几乎与W3C标准脱节 3. Trident内核的大量bug等安全性问题没有得到及时解决 4. js方面有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等 5. CSS方面，也有自己独立的处理方式，例如设置透明，低版本IE中使用滤镜的方式 前端页面由哪三层构成，及作用 分别是结构层、表示层、行为层 结构层： 由HTML或XHTML之类的标记语言负责创建。标签对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。 表示层： 由CSS负责创建，CSS对”如何显示有关内容”的问题做出了回答 行为层： 负责回答”内容应该如何对事件做出反应”这一问题，这是javascript和DOM主宰的领域 网页验证码是干嘛的 1. 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 2. 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试 为什么用多个域名存储网站资源更有效 1. CDN缓存更方便 CDN边缘节点缓存主要解决网络延迟问题 2. 突破浏览器并发限制 3. 节约cookie带宽 4. 节约主域名的连接数，优化页面响应速度 5. 防止不必要的安全问题 页面可见性API有哪些用途 页面可见性：就是对于用户来说，页面是显示还是隐藏。所谓显示的页面，就是我们正在看的页面，隐藏的页面，就是我们没有看到的页面。因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的。 API有，doucument.hidden就返回一个布尔值，如果是true，表示页面可见，false则表示页面隐藏。不同页面之间来回切换，触发visibilitychange事件。还有一个document.visibilityState，表示页面所处的状态，取值：visible,hidden等 eg: 1234567document.addEventListener(\"visibilitychange\",function(){ if (document.hidden){ document.title = \"hidden\"; } else{ document.title = \"visibile\"; }}); Quirks模式是什么，和Standards模式的区别 1. 以ie6为例，如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之间的布局方式。这就是Quirks模式(怪异模式) 2. 区别：总体会有布局、样式解析和脚本执行三个方面的区别eg: 1. 在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border 2. 设置行内元素的高宽：在 Standards 模式下，给&lt;span&gt;等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效 3. 使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效 div+css的布局较table布局有什么优点 1. 改版的时候更方便，只要改css文件 2. 页面加载速度更快、结构化清晰、页面显示简洁 3. 表现与结构相分离 4. SEO更友好，检索的排名更容易靠前 描述一下渐进增强和优雅降级之间的不同 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级意味着往回看，而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 谈一下对网页标准和标准制定机构重要性的理解 降低开发难度及开发成本，减少各种Bug、安全问题，提高网站易用性 什么是微格式 微格式是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示 如何实现一个圆形的可点击区域 border-radius。采用CSS3的圆角属性 通过事件坐标来实现eg.1234567891011121314151617181920212223242526272829303132// 获取目标元素var box = document.getElementById(\"box\");// 对目标元素target的圆形区域进行一个点击事件绑定function bindClickOnCircleArea(target, callback) { target.onclick = function(e) { e = e || window.event; // target中心点的坐标 var x1 = 100; var y1 = 100; // 事件源坐标 var x2 = e.offsetX; var y2 = e.offsetY; // 校验是否在圆形点击区，在的话就执行callback回调 // 计算事件触发点与target中心的位置 var len = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))); // 通过半径进行校验 if (len &lt;= 100) { callback(); } else { alert(\"死鬼，跑哪去啊，你老婆我是黄皮肤还是白皮肤都分不清了吗\"); } };}// 执行bindClickOnCircleArea(box, function() { alert(\"老婆，你让我好找啊，呜呜呜\");}); 通过map加areaeg.12345678910&lt;img src=\"../imgs/test.jpg\" width=\"200\" border=\"0\" usemap=\"#Map\" /&gt;&lt;!--img的usemap属性和map的name属性以及id属性相关联--&gt;&lt;map name=\"Map\" id=\"Map\"&gt; &lt;area shape=\"circle\" coords=\"100,100,100\" href=\"http://www.baidu.com\" target=\"_blank\" /&gt;&lt;/map&gt; 前端需要注意哪些SEO 1. 合理的 title、description、keywords：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可 2. 语义化的HTML代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页 3. 重要内容HTML代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 4. 重要内容不要用 js 输出：爬虫不会执行 js 获取内容 5. 少用 iframe：搜索引擎不会抓取 iframe 中的内容 6. 非装饰性图片必须加 alt，即说明文字 7. 提高网站速度：网站速度是搜索引擎排序的一个重要指标 html5有哪些新特性，移除了哪些元素新特性： 1. 拖拽释放(Drag and drop) API 2. 语义化更好的内容标签（header,nav,footer,aside,article,section） 3. 音频、视频 API(audio,video) 4. 画布(Canvas) API 5. 地理(Geolocation) API 6. 本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失； 7. sessionStorage的数据在浏览器关闭后自动删除 8. 表单控件，calendar、date、time、email、url、search 9. 新的技术 webworker, websocket, Geolocation移除的元素： 1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 2. 对可用性产生负面影响的元素：frame，frameset，noframes； html的离线储存如何使用，解释一下工作原理 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。使用方法： 只要在头部加一个manifest属性即可 1234&lt;!DOCTYPE html&gt;&lt;html manifest=\"cache.manifest\"&gt; ... &lt;/html&gt; 然后在cache.manifest文件的书写方式如下： 12345678910111213CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 离线存储的 manifest 一般由三个部分组成: 1. CACHE:表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 2. NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。 3. FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html。 浏览器是如何对HTML5的离线储存资源进行管理和加载的 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 HTML全局属性有哪些 1. accesskey:设置快捷键，提供快速访问元素如’accesskey=a’在 windows 下的 firefox 中按 alt + shift + a 可激活元素，若是Chrome则是 alt + a 2. class:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素 3. (new)contenteditable: 指定元素内容是否可编辑 4. (new)contextmenu: 自定义鼠标右键弹出菜单内容(仅Firefox支持) 5. (new)data-*: 为元素增加自定义属性 6. dir: 设置元素文本方向 ‘dir=”rtl”‘(文本从右到左) 7. (new)draggable: 设置元素是否可拖拽 8. (new)dropzone: 设置元素拖放类型： copy, move, link(没有主流浏览器支持) 9. (new)hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 10. id: 元素 id，文档内唯一 11. lang: 元素内容的的语言 12. (new)spellcheck: 是否启动拼写和语法检查 13. style: 行内 css 样式 14. tabindex: 设置元素可以获得焦点，通过 tab 可以导航 15. title: 元素相关的建议信息 16. (new)translate: 元素和子孙节点内容是否需要本地化(没有主流浏览器支持) Canvas和SVG的区别Canvas：通过 Javascript 来绘制 2D 图形。是逐像素进行渲染的。其位置发生改变，会重新进行绘制SVG：一种使用 XML 描述的 2D 图形的语言 SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。区别：Canvas 1. 依赖分辨率 2. 不支持事件处理器 3. 弱的文本渲染能力 4. 能够以 .png 或 .jpg 格式保存结果图像 5. 最适合图像密集型的游戏，其中的许多对象会被频繁重绘SVG 1. 不依赖分辨率 2. 支持事件处理器 3. 最适合带有大型渲染区域的应用程序（比如谷歌地图） 4. 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 5. 不适合游戏应用 HTML5为什么只需要写 HTML4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于SGML。而 HTML5不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML是标准通用标记语言,简单的说，就是比 HTML,XML 更老的标准，这两者都是由SGML发展而来的。但是，HTML5不是的。 meta viewport原理是什么 meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放 viewport的原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户Viewport属性值 1. width 设置 layout viewport 的宽度，为一个正整数，或字符串”width-device” 2. initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 3. minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 4. maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 5. height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用 6. user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了 对web标准、可用性、可访问性的理解可用性(Usability)：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。可访问性(Accessibility)：Web 内容对于残障用户的可阅读和可理解性可维护性(Maintainability)：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 HTML5引入哪些新的表单元素、类型和属性表单元素： 1. 规定输入域的选项列表 2. 规定用于表单的密钥对生成器字段 3. 用于不同类型的输出表单类型: date month week time number range email url color search datetime表单属性： input: autocomplete(规定 form 或 input 域应该拥有自动完成功能) autofocus(规定在页面加载时，域自动地获得焦点) form(规定输入域所属的一个或多个表单) formaction(用于描述表单提交的URL地址,会覆盖 元素中的action属性) formenctype(描述了表单提交到服务器的数据编码) formmethod(定义了表单提交的方式,覆盖了 元素的 method 属性) formnovalidate formtarget height 与 width(规定用于 image 类型的 标签的图像高度和宽度) list(规定输入域的 datalis) min 与 max(用于为包含数字或日期的 input 类型规定限定) multiple(规定 元素中可选择多个值) pattern(描述了一个正则表达式用于验证 元素的值) placeholder required(规定必须在提交之前填写输入域) step(为输入域规定合法的数字间隔) form: autocomplete novalidate(规定在提交表单时不应该验证 form 或 input 域) HTML5存储类型有什么区别cookies,seesionStorage,localStorage 共同点：都是保存到浏览器端，都是同源 区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大；seesionStroage在窗口关闭前有效，不在不同浏览器窗口共享。localStroage始终有效，永久数据，所有同源窗口共享；cookie在过期前有效，所有同源窗口共享 iframe的作用 iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载优点： 1. 便于修改，模拟分离，像一些信息管理系统会用到 2. 但现在基本不推荐使用。除非特殊需要，一般不推荐使用缺点： 1. iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级 2. iframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。 3. iframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。 标签和标签的放置位置放在中:把标签放在 之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容标签恰好放在之前:脚本在下载和执行期间会阻止 HTML 解析。把标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户例外情况：当你的脚本里包含document.write()时 什么是渐进式渲染 渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术eg: 1. 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像 2. 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容 3. 异步加载 HTML片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器 DOM和BOM的区别DOM:文档对象模型，DOM 是为了操作文档出现的 API，document 是其的一个对象。DOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容BOM:浏览器对象模型,BOM 是为了操作浏览器出现的 API，window 是其的一个对象window 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象 img上的title和alt title 指图片的信息，alt 指图片不显示时显示的文字 100×100的canvas占多少内存 40,000 bytes即4×100×100","link":"/archives/f0ff53b5.html/"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}