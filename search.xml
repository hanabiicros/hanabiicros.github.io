<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PicGo+GitHub免费图床工具</title>
      <link href="/archives/b29ed1f0.html/"/>
      <url>/archives/b29ed1f0.html/</url>
      
        <content type="html"><![CDATA[<p>PicGo+<del>GitHub</del>Gitee让你的md文档起飞</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　我在前几篇博客中提到过，如何在markdown文件中插入图片。要么是按照markdown自己的方式，使用<strong>![]()</strong>的方式，要么使用Hexo提供的<strong>标签插件</strong>。但是他们的本质都是根据图片的path，从本地中取出。这种获取图片的方式存在一个问题，即当我们更换工作环境之后，我们除了要将md文档复制过去，还要连同本地图片一起附带过去。<br>　　虽然我们可以将图片一起上传到Github上，但是这种方式无法做到对图片的统一管理。因此<strong>图床</strong>这个工具就派上大用场。<strong>图床</strong>，即<strong>自动把本地图片转换成链接</strong>的一款工具。<br>　　这次我们介绍一款非常优秀的图床工具——<strong>PicGo</strong>，它支持微博、七牛云、腾讯云COS、又拍云、GitHub、阿里云OSS、SM.MS、Imgur等8种常用图床，功能强大、界面美观、简单易用。(<del>不过有时会突然冒出一些无厘头的bug</del>)<br>　　我使用的是PicGo+GitHub，若使用其他图床工具可自行探索。</p><p><strong>更新：用了一段时间，发现GitHub图床不太行|ω・），上传速度慢，而且经常失败。后来改用了Gitee，这篇文档就当了解吧，而且Gitee图床和GitHub图床配置差不多</strong></p><h2 id="创建GitHub图床"><a href="#创建GitHub图床" class="headerlink" title="创建GitHub图床"></a>创建GitHub图床</h2><h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p>　　前两步比较简单，注意创建仓库时，用README初始化仓库</p><h3 id="生成Token"><a href="#生成Token" class="headerlink" title="生成Token"></a>生成Token</h3><p>　　点击个人头像中的”Settings”，选中个人设置中的最下面一个按钮”Developer settings”<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403195822.png" alt><br>　　然后点击”Personal access tokens”，选中”Generate new token”，生成新的令牌<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403200339.png" alt><br>　　然后选择repo权限，名称随意即可<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403200546.png" alt></p><p>(令牌生成后，<strong>只会出现一次</strong>，请将它复制下来并保存好)</p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>　　首先，你需要到GitHub上的<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo项目</a>中下载可执行文件。若是mac系统，选择dmg后缀的文件，若是window，选择exe后缀的文件。</p><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200402224805.png" alt></p><p>　　GitHub上下载资源可能会遇到网页无法访问或下载速度过慢的问题，这时候我只能说一句：“<strong>迅雷</strong>是个好东西”(ಡωಡ) 安装了迅雷的同学，直接右键使用迅雷下载即可，速度非常快。</p><h3 id="PicGo上配置GitHub图床"><a href="#PicGo上配置GitHub图床" class="headerlink" title="PicGo上配置GitHub图床"></a>PicGo上配置GitHub图床</h3><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403201635.png" alt></p><p>　　仓库名：按照”用户名/仓库名”的格式，比如我的用户名为”hanabiicros”，仓库名为”cdn”<br>　　分支名：填”master”即可<br>　　Token：中将刚刚创建的令牌粘贴在这里即可<br>　　存储路径：随意<br>　　自定义域名：按照”https://raw.githubusercontent.com/用户名/仓库名/master”的格式填写，记住一定要加master，不加master会导致生成的图片链接无法访问到</p><h3 id="PicGo设置"><a href="#PicGo设置" class="headerlink" title="PicGo设置"></a>PicGo设置</h3><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403202652.png" alt></p><p>　　在设置中，可以点开日志文件，用来查看报错信息；可以修改快捷键等。建议开启<strong>时间戳重命名</strong>，这样可以防止上传两张同名图片而导致上传失败。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
            <tag> GitHub </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/archives/5d36ff15.html/"/>
      <url>/archives/5d36ff15.html/</url>
      
        <content type="html"><![CDATA[<p>初学markdown时踩过的坑…</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>　　不得不承认，在写这篇文章前，我对markdown的使用仅仅停留在如何显示标题、链接、图片以及如何加代码块。<br>　　一开始我以为这点就够了，不过当我编辑<strong>关于</strong>页面时，我ku了。由于网上教程有些坑，加之官网的描述不甚详细，因此我决定结合我的亲身试验，对其进行总结<br><br></p><h2 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a><strong>Markdown介绍</strong></h2><p>　　Markdown 是一种<strong>轻量级标记语言</strong>，它允许人们使用易读易写的纯文本格式编写文档。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。<strong>(ps:摘自菜鸟教程)<del>个人感觉菜鸟教程更新的不够及时</del></strong><br><br></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><p>　　标题有一级到六级之分，以’#’的数量区分。一个’#’是一级标题，两个’#’是二级标题，以此类推。不过这个说白了就是加粗、加大，html实现也挺容易的。</p><p>eg:</p><blockquote><p>### 三级标题  </p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>#### 四级标题</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4></blockquote><br><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><p>　　<strong>斜体</strong>：将文字用<strong>一个</strong>*号包起来<br>　　<strong>加粗</strong>：将文字用<strong>两个</strong>*号包起来<br>　　<strong>斜体＆加粗</strong>：将文字用<strong>三个</strong>*号包起来<br>　　<strong>分隔线</strong>：用<strong>三个以上</strong>的’*‘、’-‘或’_’来建立一行分隔线<br>　　<strong>删除线</strong>：将文字用<strong>两个~</strong>号包起来<br>　　不过你也可以选择用html标签代替<del>(那你还用啥子markdown喽)</del></p><p>eg:</p><blockquote><p>*斜体*<br><em>斜体</em></p><p>**加粗**<br><strong>加粗</strong></p><p>***斜体&amp;粗体***<br><strong><em>斜体&amp;粗体</em></strong></p><p>~~删除线~~<br><del>删除线</del></p></blockquote><p><strong>分隔线</strong></p><pre><code>**** * *****</code></pre><hr><hr><hr><br><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h2><p>　　缩进：在<strong>全角</strong>模式下用空格进行缩进<br>　　换行：行尾加上两个及以上的空格然后换行；或者直接硬换行，敲个回车键。若要中间空多行可以输入多个<strong>&lt;br/&gt;</strong><br><br></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><p>　　需要引用文字，可以在其前加<strong>&gt;</strong>即可，而且支持嵌套</p><p>eg:</p><pre><code>&gt;这是引用的内容&gt;&gt;这是引用的内容的&apos;弟弟&apos;</code></pre><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容的’弟弟’</p></blockquote></blockquote><br><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h2><p>　　要插入图片，形式如下：</p><pre><code>![alt](图片地址)![alt](图片地址 &quot;title属性&quot;)</code></pre><p>　　其中，’[]’中的<strong>alt</strong>填图片的说明文字，如”图1”之类的，”title属性”可加可不加，当鼠标hover时展示的信息</p><p>eg:</p><blockquote><p>![图1](wlop01.jpg)</p></blockquote><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403205514.jpg" alt="图1"><br><br></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><p>　　插入链接，形式如下：</p><pre><code>[链接名称](链接地址)</code></pre><p>eg:</p><pre><code>[百度](https://www.baidu.com)</code></pre><blockquote><p><a href="https://www.baidu.com">百度</a></p></blockquote><br><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h2><p>　　<strong>无序列表</strong><br>　　在每个列表项之前加’+’、’-‘或’*‘即可，而且列表项与之前的符号之间必须有<strong>一个空格</strong></p><p>eg:</p><pre><code>+ 列表1- 列表2* 列表3</code></pre><blockquote><ul><li>列表1</li></ul><ul><li>列表2</li></ul><ul><li>列表3</li></ul></blockquote><p>　　<strong>有序列表</strong><br>　　列表项前用数字&amp;’.’表示</p><p>eg:</p><pre><code>1. 列表12. 列表23. 列表3</code></pre><blockquote><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol></blockquote><p>　　<strong>列表嵌套</strong><br>　　在子列表的每一项前添加四个空格即可</p><p>eg:</p><pre><code>1.第一项    + 第一项嵌套的第一个元素    + 第一项嵌套的第二个元素</code></pre><blockquote><ol><li>第一项<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li></ol></blockquote><br><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><p>　　表格用’|’来分隔不同的单元格，使用’-‘来分隔表头和其他行，而且’:-‘表示左对齐，’-:’表示右对齐，’:-:’表示居中对齐</p><p>eg:</p><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :--| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><p>　　额，应该是这个icrsus主题的设置，忽略了表格的竖线，不过也挺好看的<br><br></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><p>　　<strong>单行代码</strong><br>　　代码之间用反引号包起来<br>eg：</p><pre><code>`int a = 10;`</code></pre><p>　　<code>int a = 10;</code></p><p>　　<strong>代码块</strong><br>　　代码之间用三个反引号包起来，且反引号独占一行<br>eg:</p><pre><code>(```)  code(```)</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">code</span></span><br></pre></td></tr></table></figure><p>　　那两个小括号是为了防止其转译多加的，实际使用应去掉</p><pre><code>写到这里，也就差不多了，markdown的基本使用都介绍了，我得去修改前几篇博客的样式了(ಥ_ಥ)</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题汇总——HTML篇</title>
      <link href="/archives/f0ff53b5.html/"/>
      <url>/archives/f0ff53b5.html/</url>
      
        <content type="html"><![CDATA[<p>汇集了各个大佬的成果～(￣▽￣～)~</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>　　最近许多大厂都开启了暑期实习生招聘，看着大佬们一个个offer拿到手软，真想<del>扇自己两巴掌</del>。因此菜菜的我决定对面试题进行汇总，并且对自己的不足之处进行巩固，有备无患嘛。(主要来源：<a href="https://github.com/yisainan/web-interview/">https://github.com/yisainan/web-interview/</a>)</p><h2 id="简述对HTML语义化的理解"><a href="#简述对HTML语义化的理解" class="headerlink" title="简述对HTML语义化的理解"></a><strong>简述对HTML语义化的理解</strong></h2><p>　　1. <strong>用正确的标签做正确的事情</strong><br>　　2. HTML语义化让页面的<strong>内容结构化，结构更清晰</strong>，便于对浏览器、搜索引擎解析；即使在没有样式CSS情况下也以一种文档格式显示，并且容易阅读<br>　　3. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，<strong>利于SEO</strong><br>　　4. 使阅读网页源码的人能更容易将网站分块，<strong>便于阅读、维护以及理解</strong><br><br></p><h2 id="label标签作用以及使用方法"><a href="#label标签作用以及使用方法" class="headerlink" title="label标签作用以及使用方法"></a><strong>label标签作用以及使用方法</strong></h2><p>　　1. label标签用来定义表单控制间的关系，<strong>当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上</strong><br>　　2. 使用方法：<strong>一种是id绑定，一种是嵌套</strong><br>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"Name"</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"Name"</span> <span class="attr">id</span>=<span class="string">"Name"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"B"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="iframe框架有哪些优缺点"><a href="#iframe框架有哪些优缺点" class="headerlink" title="iframe框架有哪些优缺点"></a><strong>iframe框架有哪些优缺点</strong></h2><p><strong>优点：</strong><br>　　1. iframe能够原封不动的把嵌入的网页展示出来<br>　　2. 如果有多个网页引用iframe，那么只需修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷<br>　　3. 网页如果为了统一风格，header和footer都一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性<br>　　4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe解决</p><p><strong>缺点：</strong><br>　　1. 框架结构中出现各种滚动条<br>　　2. iframe会阻塞主页面的Onload事件，拖慢网页加载<br>　　3. 搜索引擎的检索程序无法解读这种页面，不利于SEO<br>　　4. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</p><br><h2 id="HTML与XHTML有什么区别，推荐哪个"><a href="#HTML与XHTML有什么区别，推荐哪个" class="headerlink" title="HTML与XHTML有什么区别，推荐哪个"></a><strong>HTML与XHTML有什么区别，推荐哪个</strong></h2><p>　　推荐使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：<br>　　1. XHTML中所有的标签必须闭合<br>　　2. XHTML所有标签都必须使用小写<br>　　3. 所有的XML标记都必须合理嵌套<br>　　4. 所有的参数值都必须用引号””括起来<br>　　5. 把所有&lt;和&amp;特殊符号用编码表示<br>　　6. 给所有属性赋值<br>　　7. 不要在注释内容中使用”–”<br>　　8. 图片必须使用说明文字<br>　　ps:<del>HTML<strong>元素</strong>以开始标签起始，以结束标签终止</del><br><br></p><h2 id="HTML5的form如何关闭自动填充功能"><a href="#HTML5的form如何关闭自动填充功能" class="headerlink" title="HTML5的form如何关闭自动填充功能"></a><strong>HTML5的form如何关闭自动填充功能</strong></h2><p>　　将不想要自动完成的form或input设置为<strong>autocomplete=off</strong><br><br></p><h2 id="title与h1、b与strong、i与em的区别"><a href="#title与h1、b与strong、i与em的区别" class="headerlink" title="title与h1、b与strong、i与em的区别"></a><strong>title与h1、b与strong、i与em的区别</strong></h2><p>　　1. title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，SEO权重高于h1；h1概括的是文章的主题，一个页面最好只用一个h1<br>　　2. b是为了加粗而加粗，strong是为了标明重点而加粗<br>　　3. i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i重视的多<br><br></p><h2 id="描述下SEO中的TDK"><a href="#描述下SEO中的TDK" class="headerlink" title="描述下SEO中的TDK"></a><strong>描述下SEO中的TDK</strong></h2><p>　　在SEO中，所谓的TDK就是title(标题标签)、description(描述标签)、keywords(关键词标签)这三个标签<br><br></p><h2 id="HTML文件头中的DOCTYPE的作用"><a href="#HTML文件头中的DOCTYPE的作用" class="headerlink" title="HTML文件头中的DOCTYPE的作用"></a><strong>HTML文件头中的DOCTYPE的作用</strong></h2><p>　　1. 告知浏览器，文档使用的是哪种HTML或XHTML规范<br>　　2. 告诉浏览器按照何种规范(DTD)解析页面，若没有DOCTYPE声明，那么浏览器将按照自己的方式解析渲染页面<br><br></p><h2 id="简述一下src和href区别"><a href="#简述一下src和href区别" class="headerlink" title="简述一下src和href区别"></a><strong>简述一下src和href区别</strong></h2><p>　　src用于引用资源，替换当前元素；href用于在当前文档和引用资源之间确立联系。<br>　　<strong>href:</strong><br>　　href标识超文本引用，用在link和a等标签上，是在当前元素和引用资源之间建立联系。若在文档中添加href，浏览器会识别该文档为CSS文件，就会并行下载资源并且不会停止对当前文档的处理。因此<strong>建议使用link方式加载CSS，而不是使用@import方式</strong><br>　　<strong>src:</strong><br>　　src表示引用资源，替换当前元素，用在img,script,iframe上。当浏览器解析到src，会暂停其他资源的下载和处理(图片不会)，直到将该资源加载、编译、执行完毕，类似于将所有资源引用到当前内容。因此<strong>建议把js脚本放在底部而不是头部</strong><br><br></p><h2 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a><strong>严格模式与混杂模式</strong></h2><p>　　严格模式：以浏览器支持的最高标准运行<br>　　混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为<br><br></p><h2 id="对WEB标准以及W3C的理解"><a href="#对WEB标准以及W3C的理解" class="headerlink" title="对WEB标准以及W3C的理解"></a><strong>对WEB标准以及W3C的理解</strong></h2><p>　　WEB标准简单来说可以分为<strong>结构、表现和行为</strong>。其中结构主要由HTML标签组成。表现即指CSS样式表。行为指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要由js组成<br>　　WEB标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使得这三者的界限并不那么清晰<br>　　W3C对WEB标准提出了规范化的要求，也就是在实际编程中的一些代码规范。包含如下几点：<br>　　1. 对于结构要求：<br>　　　　1. 标签字母要小写<br>　　　　2. 标签要闭合<br>　　　　3. 标签不允许随意嵌套<br>　　2. 对于CSS和js要求：<br>　　　　1. 尽量使用外联CSS样式表和js脚本。将结构、表现和行为分为三块。同时提高页面渲染速度，提高用户体验。<br>　　　　2. 样式尽量少用行间样式表，使结构和表现分离，标签的id和class等属性命名要做到见文知意，标签越少，加载越快，代码维护简单，便于改版<br>　　　　3. 不需要变动页面内容，便可提供打印版本而不需要复制内容<br><br></p><h2 id="列举IE与其他浏览器不一样的特性"><a href="#列举IE与其他浏览器不一样的特性" class="headerlink" title="列举IE与其他浏览器不一样的特性"></a><strong>列举IE与其他浏览器不一样的特性</strong></h2><p>　　1. IE的排版引擎是Trident<br>　　2. Trident内核曾经几乎与W3C标准脱节<br>　　3. Trident内核的大量bug等安全性问题没有得到及时解决<br>　　4. js方面有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等<br>　　5. CSS方面，也有自己独立的处理方式，例如设置透明，低版本IE中使用滤镜的方式<br><br></p><h2 id="前端页面由哪三层构成，及作用"><a href="#前端页面由哪三层构成，及作用" class="headerlink" title="前端页面由哪三层构成，及作用"></a><strong>前端页面由哪三层构成，及作用</strong></h2><p>　　分别是结构层、表示层、行为层<br>　　<strong>结构层：</strong><br>　　由HTML或XHTML之类的标记语言负责创建。标签对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。<br>　　<strong>表示层：</strong><br>　　由CSS负责创建，CSS对”如何显示有关内容”的问题做出了回答<br>　　<strong>行为层：</strong><br>　　负责回答”内容应该如何对事件做出反应”这一问题，这是javascript和DOM主宰的领域<br><br></p><h2 id="网页验证码是干嘛的"><a href="#网页验证码是干嘛的" class="headerlink" title="网页验证码是干嘛的"></a><strong>网页验证码是干嘛的</strong></h2><p>　　1. 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水<br>　　2. 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试<br><br></p><h2 id="为什么用多个域名存储网站资源更有效"><a href="#为什么用多个域名存储网站资源更有效" class="headerlink" title="为什么用多个域名存储网站资源更有效"></a><strong>为什么用多个域名存储网站资源更有效</strong></h2><p>　　1. CDN缓存更方便 <del>CDN边缘节点缓存主要解决网络延迟问题</del><br>　　2. 突破浏览器并发限制<br>　　3. 节约cookie带宽<br>　　4. 节约主域名的连接数，优化页面响应速度<br>　　5. 防止不必要的安全问题<br><br></p><h2 id="页面可见性API有哪些用途"><a href="#页面可见性API有哪些用途" class="headerlink" title="页面可见性API有哪些用途"></a><strong>页面可见性API有哪些用途</strong></h2><p>　　<strong>页面可见性：</strong>就是对于用户来说，页面是显示还是隐藏。所谓显示的页面，就是我们正在看的页面，隐藏的页面，就是我们没有看到的页面。因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的。<br>　　API有，<strong>doucument.hidden</strong>就返回一个布尔值，如果是true，表示页面可见，false则表示页面隐藏。不同页面之间来回切换，触发<strong>visibilitychange</strong>事件。还有一个<strong>document.visibilityState</strong>，表示页面所处的状态，取值：visible,hidden等</p><p>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden)&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"hidden"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"visibile"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><h2 id="Quirks模式是什么，和Standards模式的区别"><a href="#Quirks模式是什么，和Standards模式的区别" class="headerlink" title="Quirks模式是什么，和Standards模式的区别"></a><strong>Quirks模式是什么，和Standards模式的区别</strong></h2><p>　　1. 以ie6为例，如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之间的布局方式。这就是Quirks模式(怪异模式)<br>　　2. 区别：总体会有布局、样式解析和脚本执行三个方面的区别<br>eg:</p><pre><code>1. 在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks  模式下，IE 的宽度和高度还包含了 padding 和 border2. 设置行内元素的高宽：在 Standards 模式下，给&lt;span&gt;等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效3. 使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效</code></pre><br><h2 id="div-css的布局较table布局有什么优点"><a href="#div-css的布局较table布局有什么优点" class="headerlink" title="div+css的布局较table布局有什么优点"></a><strong>div+css的布局较table布局有什么优点</strong></h2><p>　　1. 改版的时候更方便，只要改css文件<br>　　2. 页面加载速度更快、结构化清晰、页面显示简洁<br>　　3. 表现与结构相分离<br>　　4. SEO更友好，检索的排名更容易靠前<br><br></p><h2 id="描述一下渐进增强和优雅降级之间的不同"><a href="#描述一下渐进增强和优雅降级之间的不同" class="headerlink" title="描述一下渐进增强和优雅降级之间的不同"></a><strong>描述一下渐进增强和优雅降级之间的不同</strong></h2><p>　　<strong>渐进增强：</strong>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果交互等改进和追加功能达到更好的用户体验。<br>　　<strong>优雅降级：</strong>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容<br>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级意味着往回看，而渐进增强则意味着朝前看，同时保证其根基处于安全地带。<br><br></p><h2 id="谈一下对网页标准和标准制定机构重要性的理解"><a href="#谈一下对网页标准和标准制定机构重要性的理解" class="headerlink" title="谈一下对网页标准和标准制定机构重要性的理解"></a><strong>谈一下对网页标准和标准制定机构重要性的理解</strong></h2><p>　　降低开发难度及开发成本，减少各种Bug、安全问题，提高网站易用性<br><br></p><h2 id="什么是微格式"><a href="#什么是微格式" class="headerlink" title="什么是微格式"></a><strong>什么是微格式</strong></h2><p>　　微格式是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式<br>优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示<br><br></p><h2 id="如何实现一个圆形的可点击区域"><a href="#如何实现一个圆形的可点击区域" class="headerlink" title="如何实现一个圆形的可点击区域"></a><strong>如何实现一个圆形的可点击区域</strong></h2><ol><li>border-radius。采用CSS3的圆角属性</li><li>通过事件坐标来实现<br>eg.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对目标元素target的圆形区域进行一个点击事件绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindClickOnCircleArea</span>(<span class="params">target, callback</span>) </span>&#123;</span><br><span class="line">  target.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target中心点的坐标</span></span><br><span class="line">    <span class="keyword">var</span> x1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">var</span> y1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件源坐标</span></span><br><span class="line">    <span class="keyword">var</span> x2 = e.offsetX;</span><br><span class="line">    <span class="keyword">var</span> y2 = e.offsetY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验是否在圆形点击区，在的话就执行callback回调</span></span><br><span class="line">    <span class="comment">// 计算事件触发点与target中心的位置</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(x2 - x1, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(y2 - y1, <span class="number">2</span>)));</span><br><span class="line">    <span class="comment">// 通过半径进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">"死鬼，跑哪去啊，你老婆我是黄皮肤还是白皮肤都分不清了吗"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">bindClickOnCircleArea(box, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"老婆，你让我好找啊，呜呜呜"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>通过map加area<br>eg.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../imgs/test.jpg"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">usemap</span>=<span class="string">"#Map"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--img的usemap属性和map的name属性以及id属性相关联--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"Map"</span> <span class="attr">id</span>=<span class="string">"Map"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">    <span class="attr">shape</span>=<span class="string">"circle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">coords</span>=<span class="string">"100,100,100"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><br></li></ol><h2 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a><strong>前端需要注意哪些SEO</strong></h2><p>　　1. <strong>合理的 title、description、keywords</strong>：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可<br>　　2. <strong>语义化的HTML代码</strong>，符合 W3C 规范：语义化代码让搜索引擎容易理解网页<br>　　3. <strong>重要内容HTML代码放在最前</strong>：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br>　　4. <strong>重要内容不要用 js 输出</strong>：爬虫不会执行 js 获取内容<br>　　5. <strong>少用 iframe</strong>：搜索引擎不会抓取 iframe 中的内容<br>　　6. 非装饰性图片必须加 alt，即说明文字<br>　　7. <strong>提高网站速度</strong>：网站速度是搜索引擎排序的一个重要指标<br><br></p><h2 id="html5有哪些新特性，移除了哪些元素"><a href="#html5有哪些新特性，移除了哪些元素" class="headerlink" title="html5有哪些新特性，移除了哪些元素"></a><strong>html5有哪些新特性，移除了哪些元素</strong></h2><p>新特性：<br>　　1. 拖拽释放(Drag and drop) API<br>　　2. 语义化更好的内容标签（header,nav,footer,aside,article,section）<br>　　3. 音频、视频 API(audio,video)<br>　　4. 画布(Canvas) API<br>　　5. 地理(Geolocation) API<br>　　6. 本地离线存储<strong>localStorage</strong>长期存储数据，浏览器关闭后数据不丢失；<br>　　7. sessionStorage的数据在浏览器关闭后自动删除<br>　　8. 表单控件，calendar、date、time、email、url、search<br>　　9. 新的技术 webworker, websocket, Geolocation<br>移除的元素：<br>　　1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>　　2. 对可用性产生负面影响的元素：frame，frameset，noframes；<br><br></p><h2 id="html的离线储存如何使用，解释一下工作原理"><a href="#html的离线储存如何使用，解释一下工作原理" class="headerlink" title="html的离线储存如何使用，解释一下工作原理"></a><strong>html的离线储存如何使用，解释一下工作原理</strong></h2><p>　　在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>原理：HTML5 的离线存储是基于一个新建的<strong>.appcache 文件的缓存机制</strong>(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。<br>使用方法：<br>　　只要在头部加一个<strong>manifest属性</strong>即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"cache.manifest"</span>&gt;</span></span><br><span class="line">  ...　　</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　然后在cache.manifest文件的书写方式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CACHE</span> <span class="string">MANIFEST</span></span><br><span class="line"><span class="comment">#v0.11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CACHE</span>:<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">js/app.js</span></span><br><span class="line"><span class="attr">css/style.css</span></span><br><span class="line"></span><br><span class="line"><span class="attr">NETWORK</span>:<span class="string"></span></span><br><span class="line"><span class="attr">resourse/logo.png</span></span><br><span class="line"></span><br><span class="line"><span class="attr">FALLBACK</span>:<span class="string"></span></span><br><span class="line"><span class="meta">/</span> <span class="string">/offline.html</span></span><br></pre></td></tr></table></figure><p>离线存储的 manifest 一般由三个部分组成:<br>　　1. CACHE:表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。<br>　　2. NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说<strong>CACHE的优先级更高</strong>。<br>　　3. FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html。<br><br></p><h2 id="浏览器是如何对HTML5的离线储存资源进行管理和加载的"><a href="#浏览器是如何对HTML5的离线储存资源进行管理和加载的" class="headerlink" title="浏览器是如何对HTML5的离线储存资源进行管理和加载的"></a><strong>浏览器是如何对HTML5的离线储存资源进行管理和加载的</strong></h2><p>　　在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。<br><br></p><h2 id="HTML全局属性有哪些"><a href="#HTML全局属性有哪些" class="headerlink" title="HTML全局属性有哪些"></a><strong>HTML全局属性有哪些</strong></h2><p>　　1. accesskey:设置快捷键，提供快速访问元素如’accesskey=a’在 windows 下的 firefox 中按 alt + shift + a 可激活元素，若是Chrome则是 alt + a<br>　　2. class:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素<br>　　3. <strong>(new)</strong>contenteditable: 指定元素内容是否可编辑<br>　　4. <strong>(new)</strong>contextmenu: 自定义鼠标右键弹出菜单内容(<strong>仅Firefox支持</strong>)<br>　　5. <strong>(new)</strong>data-*: 为元素增加自定义属性<br>　　6. dir: 设置元素文本方向 ‘dir=”rtl”‘(文本从右到左)<br>　　7. <strong>(new)</strong>draggable: 设置元素是否可拖拽<br>　　8. <strong>(new)</strong>dropzone: 设置元素拖放类型： copy, move, link(<strong>没有主流浏览器支持</strong>)<br>　　9. <strong>(new)</strong>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果<br>　　10. id: 元素 id，文档内唯一<br>　　11. lang: 元素内容的的语言<br>　　12. <strong>(new)</strong>spellcheck: 是否启动拼写和语法检查<br>　　13. style: 行内 css 样式<br>　　14. tabindex: 设置元素可以获得焦点，通过 tab 可以导航<br>　　15. title: 元素相关的建议信息<br>　　16. <strong>(new)</strong>translate: 元素和子孙节点内容是否需要本地化(<strong>没有主流浏览器支持</strong>)<br><br></p><h2 id="Canvas和SVG的区别"><a href="#Canvas和SVG的区别" class="headerlink" title="Canvas和SVG的区别"></a><strong>Canvas和SVG的区别</strong></h2><p><strong>Canvas：</strong>通过 Javascript 来绘制 2D 图形。是逐像素进行渲染的。其位置发生改变，会重新进行绘制<br><strong>SVG：</strong>一种使用 XML 描述的 2D 图形的语言 SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。<br><strong>区别：</strong><br>Canvas<br>　　1. 依赖分辨率<br>　　2. 不支持事件处理器<br>　　3. 弱的文本渲染能力<br>　　4. 能够以 .png 或 .jpg 格式保存结果图像<br>　　5. 最适合图像密集型的游戏，其中的许多对象会被频繁重绘<br>SVG<br>　　1. 不依赖分辨率<br>　　2. 支持事件处理器<br>　　3. 最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>　　4. 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>　　5. 不适合游戏应用<br><br></p><h2 id="HTML5为什么只需要写"><a href="#HTML5为什么只需要写" class="headerlink" title="HTML5为什么只需要写"></a><strong>HTML5为什么只需要写<!DOCTYPE HTML></strong></h2><p>　　HTML4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于<strong>SGML</strong>。而 HTML5不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML是标准通用标记语言,简单的说，就是比 HTML,XML 更老的标准，这两者都是由SGML发展而来的。但是，HTML5不是的。<br><br></p><h2 id="meta-viewport原理是什么"><a href="#meta-viewport原理是什么" class="headerlink" title="meta viewport原理是什么"></a><strong>meta viewport原理是什么</strong></h2><p>　　meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放<br>　　<strong>viewport的原理</strong>：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户<br><strong>Viewport属性值</strong><br>　　1. width 设置 layout viewport 的宽度，为一个正整数，或字符串”width-device”<br>　　2. initial-scale 设置页面的初始缩放值，为一个数字，可以带小数<br>　　3. minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数<br>　　4. maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数<br>　　5. height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用<br>　　6. user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了<br><br></p><h2 id="对web标准、可用性、可访问性的理解"><a href="#对web标准、可用性、可访问性的理解" class="headerlink" title="对web标准、可用性、可访问性的理解"></a><strong>对web标准、可用性、可访问性的理解</strong></h2><p><strong>可用性(Usability)</strong>：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。<br><strong>可访问性(Accessibility)</strong>：Web 内容对于残障用户的可阅读和可理解性<br><strong>可维护性(Maintainability)</strong>：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。<br><br></p><h2 id="HTML5引入哪些新的表单元素、类型和属性"><a href="#HTML5引入哪些新的表单元素、类型和属性" class="headerlink" title="HTML5引入哪些新的表单元素、类型和属性"></a><strong>HTML5引入哪些新的表单元素、类型和属性</strong></h2><p>表单元素：<br>　　1. <datalist>规定输入域的选项列表<br>　　2. <keygen>规定用于表单的密钥对生成器字段<br>　　3. </datalist><output>用于不同类型的输出<br>表单类型:<br>　　date month week time number range email url color search datetime<br>表单属性：<br>　　<strong>input:</strong><br>        autocomplete(规定 form 或 input 域应该拥有自动完成功能)<br>        autofocus(规定在页面加载时，域自动地获得焦点)<br>        form(规定输入域所属的一个或多个表单)<br>        formaction(用于描述表单提交的URL地址,会覆盖<form> 元素中的action属性)<br>        formenctype(描述了表单提交到服务器的数据编码)<br>        formmethod(定义了表单提交的方式,覆盖了 <form> 元素的 method 属性)<br>        formnovalidate<br>        formtarget<br>        height 与 width(规定用于 image 类型的 <input> 标签的图像高度和宽度)<br>        list(规定输入域的 datalis)<br>        min 与 max(用于为包含数字或日期的 input 类型规定限定)<br>        multiple(规定<input> 元素中可选择多个值)<br>        pattern(描述了一个正则表达式用于验证 <input> 元素的值)<br>        placeholder<br>        required(规定必须在提交之前填写输入域)<br>        step(为输入域规定合法的数字间隔)<br>　　<strong>form:</strong><br>        autocomplete<br>        novalidate(规定在提交表单时不应该验证 form 或 input 域)<br><br></form></form></output></p><h2 id="HTML5存储类型有什么区别"><a href="#HTML5存储类型有什么区别" class="headerlink" title="HTML5存储类型有什么区别"></a><strong>HTML5存储类型有什么区别</strong></h2><p><strong>cookies,seesionStorage,localStorage</strong><br>　　共同点：都是保存到浏览器端，都是同源<br>　　区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大；seesionStroage在窗口关闭前有效，不在不同浏览器窗口共享。localStroage始终有效，永久数据，所有同源窗口共享；cookie在过期前有效，所有同源窗口共享<br><br></p><h2 id="iframe的作用"><a href="#iframe的作用" class="headerlink" title="iframe的作用"></a><strong>iframe的作用</strong></h2><p>　　iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载<br><strong>优点：</strong><br>　　1. 便于修改，模拟分离，像一些信息管理系统会用到<br>　　2. 但现在基本不推荐使用。除非特殊需要，一般不推荐使用<br><strong>缺点：</strong><br>　　1. iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级<br>　　2. iframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。<br>　　3. iframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。<br><br></p><h2 id="标签和标签的放置位置"><a href="#标签和标签的放置位置" class="headerlink" title="标签和标签的放置位置"></a><strong><link>标签和<script>标签的放置位置</strong></h2><p><strong><link>放在<head>中:</strong>把<link>标签放在<head><link rel="alternate" href="/atom.xml" title="icrosの小窝" type="application/atom+xml"></head>之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容<br><strong><script>标签恰好放在</body>之前:</strong>脚本在下载和执行期间会阻止 HTML 解析。把<script>标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户<br><strong>例外情况</strong>：当你的脚本里包含document.write()时<br><br/></p><h2 id="什么是渐进式渲染"><a href="#什么是渐进式渲染" class="headerlink" title="什么是渐进式渲染"></a><strong>什么是渐进式渲染</strong></h2><p>　　渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术<br>eg:<br>　　1. 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像<br>　　2. 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容<br>　　3. 异步加载 HTML片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器<br><br/></p><h2 id="DOM和BOM的区别"><a href="#DOM和BOM的区别" class="headerlink" title="DOM和BOM的区别"></a><strong>DOM和BOM的区别</strong></h2><p><strong>DOM</strong>:文档对象模型，DOM 是为了操作文档出现的 API，document 是其的一个对象。DOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容<br><strong>BOM</strong>:浏览器对象模型,BOM 是为了操作浏览器出现的 API，window 是其的一个对象<br>window 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象<br><br/></p><h2 id="img上的title和alt"><a href="#img上的title和alt" class="headerlink" title="img上的title和alt"></a><strong>img上的title和alt</strong></h2><p>　　title 指图片的信息，alt 指图片不显示时显示的文字<br><br/></p><h2 id="100×100的canvas占多少内存"><a href="#100×100的canvas占多少内存" class="headerlink" title="100×100的canvas占多少内存"></a><strong>100×100的canvas占多少内存</strong></h2><p>　　40,000 bytes即4×100×100</p></script></strong></h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo创建博客(进阶篇)</title>
      <link href="/archives/413d9fe2.html/"/>
      <url>/archives/413d9fe2.html/</url>
      
        <content type="html"><![CDATA[<p>这是对基础篇的补充，方便了解Hexo，并对其进行个性化配置</p><a id="more"></a><h2 id="Hexo基本配置"><a href="#Hexo基本配置" class="headerlink" title="Hexo基本配置"></a><strong>Hexo基本配置</strong></h2><h3 id="config-yml配置文件"><a href="#config-yml配置文件" class="headerlink" title="_config.yml配置文件"></a>_config.yml配置文件</h3><p>　　该文件中是整个’Hexo’框架的配置文件，下面对其部分参数信息进行描述.</p><h4 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">icrosの小窝</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'帅斌的博客'</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Yaobin</span> <span class="string">Zhang</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;title&apos;：网站的标题-&apos;subtitle&apos;：网站的副标题-&apos;description&apos;：网站的描述，用于SEO-&apos;keywords&apos;：网站的关键词-&apos;author&apos;：网站的作者-&apos;language&apos;：网站所使用的语言，默认是en，你可以改为&apos;zh-CN&apos;简体中文-&apos;timezone&apos;：网站的时区，默认使用你电脑的时区</code></pre><br><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://hanabiicros.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;url&apos;：网址，如果你的网站是放在子路径下，则将其设置为&apos;http://yoursite.com/child&apos;-&apos;root&apos;：网站的根目录-&apos;permalink&apos;：文章的永久链接格式，即发布的文章在网站下生成的路径格式，默认是&apos;yoursite.com/year/month/day/title&apos;-&apos;pretty_urls&apos;：改写permalink的值来美化URL-&apos;pretty_urls.trailing_index&apos;：是否在永久链接中保留尾部的index.html-&apos;pretty_urls.trailing_html&apos;：是否在永久链接中保留尾部的.html</code></pre><br><h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure><p>　　主要配置了各个文件夹的存放位置，另外’skip_render’表示跳过指定文件的渲染，即你可以使用自己的样式，一般默认即可。<br><br></p><h4 id="home-page-setting"><a href="#home-page-setting" class="headerlink" title="home page setting"></a>home page setting</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;index_generator.path&apos;：指明博客主页的根路径-&apos;index_generator.per_page&apos;：每页显示的最多文章数-&apos;index_generator.order_by&apos;：文章的排序方式</code></pre><br><h4 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">icarus</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;theme&apos;：当前主题名称-&apos;theme_config&apos;：主题的配置文件，会覆盖主题目录下的&apos;_config.yml&apos;中的配置-&apos;deploy&apos;：部署部分的设置</code></pre><p>　　其他配置默认即可，详细信息可见<a href="https://hexo.io/zh-cn/docs">官方文档</a><br><br></p><h2 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a><strong>Hexo基本操作</strong></h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>　　‘基础篇’中讲了用如下命令，新建一篇文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">'title'</span></span><br></pre></td></tr></table></figure><p>　　除了新建文章外，还可以新建页面’page’或者草稿’draft’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">'title'</span></span><br><span class="line">hexo new draft <span class="string">'title'</span></span><br></pre></td></tr></table></figure><p>　　其中新建的页面’page’的’title’，和你在导航栏中自定义的路径’/title’相匹配的。即点击导航栏的’title’按钮，会定位到这个页面中。<del>(ps:当初看官方文档的时候看到了这里，不过没仔细看，结果在’关于’页面卡了好久，不知道怎么加这个页面。han(lll￢ω￢))</del><br><br></p><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>　　Front-matter是每个post中最上方以’—‘分割的区域，指定个别文件的变量</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">基于Hexo创建博客(进阶篇)</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-26</span> <span class="number">22</span><span class="string">:08:31</span></span><br><span class="line"><span class="attr">thumbnail:</span> <span class="string">/images/wc01.jpg</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span>            <span class="comment">#标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">技术</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;title&apos;：标题-&apos;date&apos;：建立日期-&apos;updated&apos;：更新日期-&apos;tags&apos;：标签，网站会根据每篇文章的标签进行归类-&apos;categories&apos;：分类，同样网站会根据每篇文章所属分类进行归类-&apos;comments&apos;：开启文章的评论功能，不加默认开启-&apos;permalink&apos;：覆盖文章的网址</code></pre><p>　　另外’thumbnail’和’toc’是’icarus’主题特有的。<br><br></p><h3 id="资源插入"><a href="#资源插入" class="headerlink" title="资源插入"></a>资源插入</h3><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>　　在Hexo 2之前，许多人是推荐安装’hexo-asset-image’，该插件貌似是解决了因常规的md语法和相对路径引用资源的方式造成在存档页和主页显示不正确的问题<del>(ps:因为我是一上手就直接体验icarus主题，因而没遇到这个问题，况且我还是最新版的Hexo呢)</del></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">https://github.com/CodeFalling/hexo-asset-image</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><p>　　然后在博客根目录下的’_config.yml’文件中将’post_asset_folder’属性设置为true，这样在每次创建新的文章时，他会自动在同目录下创建一个同名的文件夹，该文件夹用于存放与文章相关的资源。<br>　　接着用传统的md形式就能实现图片的插入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">![title](xxx.jpg/png)</span></span><br></pre></td></tr></table></figure><p>　　但是我在官方提供的插件库中，并未找到’hexo-asset-image’，只有’hexo-asset’，不过提供的功能大致是一样的。<br><br></p><h4 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h4><p>　　除了上述方法，在Hexo 3中，官方提供了名为’标签插件’的东东</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">asset_path</span> <span class="string">slug</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">asset_img</span> <span class="string">slug</span> <span class="string">[title]</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">asset_link</span> <span class="string">slug</span> <span class="string">[title]</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure><p>　　像这样也可以实现路径、图片、链接的插入，当然这个功能是很强大的，官方提供了’引用块’、’代码块’、’Image’、’Youtube’等的插入方式。<br>对于码农而言，主要用到的还是代码块的插入。一般使用，只需指明使用的语言’lang:’即可，而且它默认显示行号。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">codeblock</span> <span class="string">[title]</span> <span class="string">[lang:language]</span> <span class="string">[url]</span> <span class="string">[link</span> <span class="string">text]</span> <span class="string">[additional</span> <span class="string">options]</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">code</span> <span class="string">snippet</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">endcodeblock</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure><p>　　还有一种就是用反引号的形式(格式问题，不能换行只能放在一行，实际使用将代码和第二个反引号换行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` [language] [title] [url] [link <span class="built_in">text</span>] code snippet```</span><br></pre></td></tr></table></figure><br><h2 id="Hexo插件"><a href="#Hexo插件" class="headerlink" title="Hexo插件"></a><strong>Hexo插件</strong></h2><h3 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h3><p>　　由于Hexo在生成博客文章链接时，默认是按照年/月/日/标题的格式，这样生成的链接太过冗长，虽然可以在_config.yml中修改”permalink”的格式，但是这样还是无法保证链接的唯一性，而且可能会造成链接的格式混乱。<br>　　而hexo-abbrlink插件可以生成唯一文章链接，而且配置十分简单。先安装该插件，在博客根目录，右键”Git Bush Here”，打开git控制台，然后输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>　　接着在博客根目录下的_config.yml文件中，设置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html/</span>   <span class="comment">#archives的位置可以随意命名，或archives/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure><h3 id="hexo-generator-feed"><a href="#hexo-generator-feed" class="headerlink" title="hexo-generator-feed"></a>hexo-generator-feed</h3><p>　　首先，我们需要了解<strong>什么是RSS</strong>，RSS指Really Simple Syndication(真正简易联合)。RSS是我们有能力聚合网站的内容，它定义了非常简单的方法来共享和查看标题和内容。RSS文件可被自动更新，且允许为不同的网站进行视图的个性化。<br>　　之所以使用RSS，是为了让订阅RSS的用户不必每日来您的网站检查更新，他可以使用RSS聚合器来检查更新。<br>　　先安装hexo-generator-feed，git控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>　　然后在_config.yml文件中在<strong>Extension</strong>位置，添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">icarus</span></span><br><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>　　设置完毕后，你的RSS链接就是<strong>域名/atom.xml</strong>。一般RSS功能在页面上的标志是”wifi信号”</p><h3 id="hexo-lazyload-image"><a href="#hexo-lazyload-image" class="headerlink" title="hexo-lazyload-image"></a>hexo-lazyload-image</h3><p>　　由于图片等静态资源的加载，需要花费较多的时间，因此我们需要优化网站图片加载的速度。图片懒加载是一种常用的方法。hexo-lazyload-image插件会将博客中img标签的src属性替换为一个loading image，把真实的图片地址放在data-origin属性下面，然后当加载到该图片时，它会用一段js将data-origin的内容替换为src，达到懒加载的目的。<br>　　首先，进入博客根目录下安装该插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><p>　　然后在_config.yml配置文件中，添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">onlypost:</span> <span class="literal">false</span>   <span class="comment">#若为true,则只有在post和page中会支持懒加载</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="comment"># eg ./images/loading.gif   #如果不填，使用默认的加载图片，若想自定义，可将相应图片放到文件夹中，并填写相应的路径</span></span><br></pre></td></tr></table></figure><p>eg:<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406221715.png" alt></p><h3 id="valine评论插件"><a href="#valine评论插件" class="headerlink" title="valine评论插件"></a>valine评论插件</h3><p>　　由于我使用的icarus主题已经集成了valine评论插件功能，因此只需要在主题文件夹下的_config.yml文件中添加上valine插件的<strong>app_id</strong>和<strong>app_key</strong>即可。获取方法，登录<a href="https://www.leancloud.cn/">LeanCloud官网</a>，注册LeanCloud账号。<br>　　然后创建应用，选择开发版，名称随意，如下：<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406223858.png" alt><br>　　接着在<strong>设置</strong>-<strong>应用Keys</strong>中就可以看到你的AppID和AppKey，如下：<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406224031.png" alt><br>　　若想管理评论数据，可以在<strong>存储</strong>-<strong>结构化数据</strong>-<strong>Comment</strong>中设置：<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406224349.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo创建博客(基础篇)</title>
      <link href="/archives/5ec59427.html/"/>
      <url>/archives/5ec59427.html/</url>
      
        <content type="html"><![CDATA[<p>　　这只是个最基础的教程，参考了知乎上“洪卫”dl的文章——“Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)”。<br>　　其他各种自定义配置详见“大佬”的教程（｡ò ∀ ó｡）</p><a id="more"></a><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a><strong>安装Git</strong></h2><p>　　Git作为目前世界上最先进的<strong>分布式版本控制系统</strong>，拥有强大的项目版本管理能力。<del>(ps:不过我暂时还没去深入了解，(lll￢ω￢))</del><br>　　Windows直接到官网下载就行，Linux的话直接一行shell命令解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a><strong>安装Node.js</strong></h2><p>　　因为’Hexo’是基于’Node.js’编写的，所以需要先安装’Node.js’以及包管理工具’npm’<br>　　同样Windows到官网下载，无脑安装即可，Linux还是命令行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>　　前两个工具安装完毕之后，就可以安装’Hexo’了。<br>　　先创建一个文件夹用于存放博客文件，我是放在’D:\Study\MyBlog’下。接着在该目录下右键点击’Git Bash Here’,打开’git’的控制台窗口。输入如下命令全局安装hexo脚手架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>　　安装完成后，可以输入’hexo -v’检查是否安装成功</p><h3 id="Hexo初始化自己的网站"><a href="#Hexo初始化自己的网站" class="headerlink" title="Hexo初始化自己的网站"></a>Hexo初始化自己的网站</h3><p>　　在git控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init BinBlog</span><br></pre></td></tr></table></figure><p>　　初始化自己网站，其中’BinBlog’是我自己命名的博客网站名称，可随意命名</p><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><p>　　进入刚创建的博客目录，安装依赖项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> BinBlog</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>　　安装完毕后，在响应的博客目录下，可以看到如下文件夹：</p><pre><code>-&apos;node_modules&apos;:依赖包-&apos;public&apos;:存放生成的页面，包括html、css、js等-&apos;scaffolds&apos;:生成文章的一些模板，比如草稿md、页面md以及文章md-&apos;source&apos;:存放你写的文章以及你需要自己添加的一些资源文件-&apos;themes&apos;:主题文件，Hexo有多种主题，默认使用的是&apos;landscape&apos;主题-&apos;_config.yml&apos;:博客的配置文件，其中可以配置网站的各种属性，之后再说</code></pre><h3 id="预览默认博客页面"><a href="#预览默认博客页面" class="headerlink" title="预览默认博客页面"></a>预览默认博客页面</h3><p>　　输入’hexo g’生成静态页面，然后输入’hexo s’打开本地服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>　　服务器会开放4000端口，浏览器打开’localhost:4000/‘可以看到默认的博客页面。<br>　　emmmm，不得不说这个默认的页面感觉有点丑，不过不要紧，后续我会提供本网站所使用的主题icarus的教程。</p><h2 id="Github上创建个人仓库"><a href="#Github上创建个人仓库" class="headerlink" title="Github上创建个人仓库"></a><strong>Github上创建个人仓库</strong></h2><p>　　在如图1位置’New repository’，新建个人仓库<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403205753.png" alt="图1"><br>　　然后在’Repository name’字段处填自己的github账号名称+’github.io’，这样当部署到’yourname.github.io’网址时，才会识别到你的仓库，另外在初始化时附带上README。如图2所示<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403205958.png" alt="图2"></p><h2 id="生成SSH并添加到Github"><a href="#生成SSH并添加到Github" class="headerlink" title="生成SSH并添加到Github"></a><strong>生成SSH并添加到Github</strong></h2><p>　　在git控制台输入如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>　　全局设置到指定的Git仓库。网上给的设置邮箱的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global At-Cost Domain Pricing - Domain Cost Club <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>　　但是我输入之后提示错误信息…<br>　　接着创建’SSH’，学过信息安全的应该都知道。说白了就是通过公私钥匹配，将你的文件上传到’GitHub’上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>　　然后一般在你的’C:\Users\xxx&#39;目录下，会生成’.ssh’文件夹，里面有你的私钥和公钥。可能我之前生成过ssh，已经有了该目录，就不演示了。<br>　　接着将生成的公钥’id_rsa.pub’的内容复制到你的github上，如图3所示。<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403210234.png" alt="图3"><br>　　即在setting中的’SSH and GPG keys’中’New SSH key’，给其取个名字，然后将复制的公钥粘贴到此处。<br>　　在git控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>　　若出现你的用户名，即配置成功</p><h2 id="将hexo部署到GitHub上"><a href="#将hexo部署到GitHub上" class="headerlink" title="将hexo部署到GitHub上"></a><strong>将hexo部署到GitHub上</strong></h2><p>　　接着我们就可以将hexo生成的网页托管到GitHub上。</p><h3 id="修改’-config-yml’文件"><a href="#修改’-config-yml’文件" class="headerlink" title="修改’_config.yml’文件"></a>修改’_config.yml’文件</h3><p>　　打开博客根目录下的’_config.yml’配置文件，修改最后一行的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/hanabiicros/hanabiicros.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>　　‘repository’的位置填写自己的github地址即可。这样通过git命令上传的文件就会放到你的仓库中</p><h3 id="安装deploy-git"><a href="#安装deploy-git" class="headerlink" title="安装deploy-git"></a>安装deploy-git</h3><p>　　需要先安装部署的命令，才能用’git d’上传到’GitHub’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>　　然后执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>　　‘hexo c’即清除命令，这个命令还是挺好用的，如果你遇到一般的小bug，那就’hexo c’然后再执行。’hexo g’即生成静态网页，’hexo d’部署文章。若提示’Deploy done:git’即操作成功。之后就能在’yourname.github.io’网站上看到你的博客。</p><h2 id="写文章并发布"><a href="#写文章并发布" class="headerlink" title="写文章并发布"></a><strong>写文章并发布</strong></h2><p>　　完成了上述基本步骤之后，你如果就用默认的主题的话，那么你就可以开始撰写你的第一个’纯文本’博客了。之所以说是’纯文本’，是因为还有许多hexo插件没有介绍。具体内容将放在下一篇进行具体说明。<br>　　现在你需要做的就是在博客的根目录下输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">"arctile title"</span></span><br></pre></td></tr></table></figure><p>　　新建一篇文章，然后在博客根目录下的’source_posts’的目录下多了一个’xxx.md’的文件，这就是你刚刚创建的。接着就可以进入’vscode’中编辑’markdown’文件了。编写完后执行固定的这三个命令’hexo c’、’hexo g’、’hexo d’。你也可以在提交前先进行本地预览，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>　　到这里一个最基本的博客就搭建完毕了。下一篇会对里面的具体配置内容进行相关介绍，并进行个性化定制！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
