<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试汇总——js</title>
      <link href="/archives/aaea6312.html/"/>
      <url>/archives/aaea6312.html/</url>
      
        <content type="html"><![CDATA[<p>重中之重的js篇</p><a id="more"></a><h2 id="document-load和document-ready的区别"><a href="#document-load和document-ready的区别" class="headerlink" title="document load和document ready的区别"></a><strong>document load和document ready的区别</strong></h2><p>　　1. load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数<br>问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响<br>　　2. $(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行。在原生的js中不包括ready()这个方法，只有load方法也就是onload事件<br><br/></p><h2 id="js中的基本数据类型和引用数据类型"><a href="#js中的基本数据类型和引用数据类型" class="headerlink" title="js中的基本数据类型和引用数据类型"></a><strong>js中的基本数据类型和引用数据类型</strong></h2><p><strong>基本类型(Undefined/Null/Boolean/Number/String/Symbol)：</strong>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。它们是直接按值存放的，可以直接访问<br><strong>引用类型(Object/Array/RegExp/Date/Function)：</strong>存放在堆内存中的对象；每个空间大小不一样，根据情况进行特定的分配。当我们需要访问引用数据类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。<br><br/></p><h2 id="JavaSript中如何检测一个变量是一个String类型"><a href="#JavaSript中如何检测一个变量是一个String类型" class="headerlink" title="JavaSript中如何检测一个变量是一个String类型"></a><strong>JavaSript中如何检测一个变量是一个String类型</strong></h2><ol><li>typeof:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="string">'123'</span>) === <span class="string">"strig"</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li>constructor:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'123'</span>.constructor === <span class="built_in">String</span></span><br></pre></td></tr></table></figure></li><li>Object.prototype.toString.call()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'123'</span>) === <span class="string">'[object String]'</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="请用js去除字符串空格"><a href="#请用js去除字符串空格" class="headerlink" title="请用js去除字符串空格"></a><strong>请用js去除字符串空格</strong></h2><p>　　1. replace正则匹配方法<br>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/\s*/g</span>, <span class="string">""</span>);  <span class="comment">// \s表示空格，g表示全局匹配，*表示匹配零个或多个</span></span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//去除字符串所有空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6//输出左右侧均无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/^\s*/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">//6 6 //输出右侧有空格左侧无空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 6 6 "</span>;</span><br><span class="line"><span class="keyword">var</span> str_1 = str.replace(<span class="regexp">/\s*$/g</span>, <span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str_1); <span class="comment">// 6 6//输出左侧有空格右侧无空格</span></span><br></pre></td></tr></table></figure><p>　　2. str.trim()方法<br>　　trim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串<br>　　3. JQ 方法：$.trim(str)方法<br><br/></p><h2 id="js是一门怎样的语言，有什么特点"><a href="#js是一门怎样的语言，有什么特点" class="headerlink" title="js是一门怎样的语言，有什么特点"></a><strong>js是一门怎样的语言，有什么特点</strong></h2><p>　　脚本语言。JavaScript 是一种解释型的脚本语言,C、C++等语言先编译后执行,而 JavaScript 是在程序的运行过程中逐行进行解释。<br>特点：<br>　　1. 基于对象。JavaScript 是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。<br>　　2. 简单。JavaScript 语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于 Java 基本语句和控制的脚本语言,其设计简单紧凑。<br>　　3. 动态性。JavaScript 是一种采用事件驱动的脚本语言,它不需要经过 Web 服务器就可以对用户的输入做出响应。<br>　　4. 跨平台性。JavaScript 脚本语言不依赖于操作系统,仅需要浏览器的支持。<br><br/></p><h2 id="和-的不同"><a href="#和-的不同" class="headerlink" title="== 和 === 的不同"></a><strong>== 和 === 的不同</strong></h2><p>　　== 是<strong>抽象相等运算符</strong>，而 === 是严格相等运算符。==运算符是在进行必要的类型转换后，再比较。=== 运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回false。使用== 时，可能发生一些特别的事情。<br>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">"1"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">""</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">"0"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br/><h2 id="如何添加、移除、移动、复制、创建和查找节点"><a href="#如何添加、移除、移动、复制、创建和查找节点" class="headerlink" title="如何添加、移除、移动、复制、创建和查找节点"></a><strong>如何添加、移除、移动、复制、创建和查找节点</strong></h2><ol><li>创建新节点<br>　　createDocumentFragment() //创建一个 DOM 片段<br>　　createElement() //创建一个具体的元素<br>　　createTextNode() //创建一个文本节点</li><li>添加、移除、替换、插入<br>　　appendChild() //添加<br>　　removeChild() //移除<br>　　replaceChild() //替换<br>　　insertBefore() //插入</li><li>查找<br>　　getElementsByTagName() //通过标签名称<br>　　getElementsByName() //通过元素的 Name 属性的值<br>　　getElementById() //通过元素 Id，唯一性<br/></li></ol><h2 id="事件委托是什么"><a href="#事件委托是什么" class="headerlink" title="事件委托是什么"></a><strong>事件委托是什么</strong></h2><p>　　利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行</p><ol><li>那什么样的事件可以用事件委托，什么样的事件不可以用呢？<br>　　适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。<br>　　值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。<br>　　不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没有冒泡的特性，自然就不用事件委托了。</li><li>为什么要用事件委托<br>　　1. 提高性能<br>eg:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>凤梨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// good</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).onclick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> target = event.target</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">if</span> (target.nodeName === <span class="string">'li'</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(target.innerHTML)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// bad</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>).forEach(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">  e.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>　　2. 新添加的元素还会有之前的事件</li><li>事件冒泡与事件委托的对比<br>　　事件冒泡：box 内部无论是什么元素，点击后都会触发 box 的点击事件<br>　　事件委托：可以对 box 内部的元素进行筛选</li><li>事件委托怎么取索引？<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaaaaaaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>事件委托了 点击当前，如何获取 这个点击的下标<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>cccccccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> aLi = oUl.getElementsByTagName(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="actionscript">        oUl.onclick = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> target = ev.target || ev.srcElement;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (target.nodeName.toLowerCase() == <span class="string">"li"</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> that = target;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> index;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aLi.length; i++)</span></span><br><span class="line">                    if (aLi[i] === target) index = i;</span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) alert(<span class="string">'我的下标是第'</span> + index + <span class="string">'个'</span>);</span></span><br><span class="line"><span class="actionscript">                target.style.background = <span class="string">"red"</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="require与import的区别"><a href="#require与import的区别" class="headerlink" title="require与import的区别"></a><strong>require与import的区别</strong></h2><p>　　两者的加载方式不同、规范不同</p><ol><li>两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./a'</span>)(); <span class="comment">// a 模块是一个函数，立即执行 a 模块函数</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'./a'</span>).data; <span class="comment">// a 模块导出的是一个对象</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)[<span class="number">0</span>]; <span class="comment">// a 模块导出的是一个数组 ======&gt; 哪都行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> _ <span class="keyword">from</span> <span class="string">'_'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;a,b,c&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> alias, a <span class="keyword">as</span> a_a, b, c&#125; <span class="keyword">from</span> <span class="string">'./a'</span>; ======&gt;用在开头</span><br></pre></td></tr></table></figure></li><li>规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范</li><li>require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化；import 特点：<strong>语言规格层面</strong>支持模块功能。支持<strong>编译时静态分析</strong>，便于 JS 引入宏和类型检验。<strong>动态绑定</strong>。<br/></li></ol><h2 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a><strong>javascript对象的几种创建方式</strong></h2><ol><li>Object构造函数创建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.name = <span class="string">"Nike"</span>;</span><br><span class="line">Person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。</li><li>使用对象字面量表示法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;&#125;; <span class="comment">//相当于 var Person = new Object();</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">4name: <span class="string">'Nike'</span>;</span><br><span class="line">4age: <span class="number">29</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>对象字面量</strong>是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同<br>　　在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是<strong>第一种，第二种方法的缺点</strong>所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。<br>3. 使用工厂模式创建对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nike"</span>, <span class="number">29</span>, <span class="string">"teacher"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Arvin"</span>, <span class="number">20</span>, <span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就<strong>无法判断返回的对象究竟是一个什么样的类型</strong>。于是就出现了第四种创建对象的模式<br>4. 使用构造函数创建对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nike"</span>, <span class="number">29</span>, <span class="string">"teacher"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Arvin"</span>, <span class="number">20</span>, <span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>对比工厂模式，我们可以发现以下区别：<br>　　1. 没有显示地创建对象<br>　　2. 直接将属性和方法赋给了 this 对象<br>　　3. 没有 return 语句<br>　　4. 终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//ture</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//ture</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//ture</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//ture</span></span><br></pre></td></tr></table></figure><p>同时我们也应该明白，按照惯例，<strong>构造函数始终要应该以一个大写字母开头</strong>，而非构造函数则应该以一个小写字母开头。那么构造函数确实挺好用的，但是它也有它的缺点：<br>就是<strong>每个方法都要在每个实例上重新创建一遍</strong>，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法<br>5. 原型创建对象模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nike"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.jbo = <span class="string">"teacher"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure><p>使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。<br>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nike"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.jbo = <span class="string">"teacher"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name); <span class="comment">//'Greg' --来自实例</span></span><br><span class="line">alert(person2.name); <span class="comment">//'Nike' --来自原型</span></span><br></pre></td></tr></table></figure><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。<br>这时候我们就可以使用构造函数模式与原型模式结合的方式，<strong>构造函数模式</strong>用于<strong>定义实例属性</strong>，而<strong>原型模式</strong>用于<strong>定义方法和共享的属性</strong><br>6. 组合使用构造函数模式和原型模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">4<span class="keyword">this</span>.name = name;</span><br><span class="line">4<span class="keyword">this</span>.age = age;</span><br><span class="line">4<span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">4<span class="keyword">constructor</span>: Person, //<span class="keyword">constructor</span>属性返回对此创建对象的函数的引用</span><br><span class="line">4sayName: function() &#123;</span><br><span class="line">44alert(<span class="keyword">this</span>.name);</span><br><span class="line">4&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nike'</span>, <span class="number">20</span>, <span class="string">'teacher'</span>);</span><br></pre></td></tr></table></figure><br/><h2 id="javascript继承的方式和优缺点"><a href="#javascript继承的方式和优缺点" class="headerlink" title="javascript继承的方式和优缺点"></a><strong>javascript继承的方式和优缺点</strong></h2><ol><li>原型链继承<br>缺点：<ul><li>引用类型的属性被所有实例共享</li><li>在创建 Child 的实例时，不能向 Parent 传参</li></ul></li><li>借用构造函数(经典继承)<br>优点：<ul><li>避免了引用类型的属性被所有实例共享</li><li>可以在 Child 中向 Parent 传参<br>缺点：</li><li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ul></li><li>组合继承<br>优点：<ul><li>融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</li></ul></li><li>原型式继承<br>缺点：<ul><li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li></ul></li><li>寄生式继承<br>缺点：<ul><li>跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</li></ul></li><li>寄生组合式继承<br>优点：<ul><li>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。</li><li>与此同时，原型链还能保持不变；</li><li>因此，还能够正常使用 instanceof 和 isPrototypeOf。</li></ul></li></ol><p><strong>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式</strong><br><br/></p><h2 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a><strong>什么是原型链</strong></h2><p>　　通过一个对象的<strong>proto</strong>可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的<strong>proto</strong>，最后找到了我们的 Object.prototype,从实例的原型对象开始一直到 Object.prototype 就是我们的原型链<br>eg:<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200428221052.png" alt=""></p><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200615111449.png" alt=""><br><br/></p><h2 id="复杂数据类型如何转变为字符串"><a href="#复杂数据类型如何转变为字符串" class="headerlink" title="复杂数据类型如何转变为字符串"></a><strong>复杂数据类型如何转变为字符串</strong></h2><ol><li>首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值，</li><li>如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法，</li><li>如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，</li><li>如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'1'</span></span><br><span class="line"><span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'[object Object]';</span></span><br><span class="line"><span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">//'1';</span></span><br><span class="line"><span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="string">""</span>); <span class="comment">// 报错 Uncaught TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="javascript-的-typeof-返回哪些数据类型"><a href="#javascript-的-typeof-返回哪些数据类型" class="headerlink" title="javascript 的 typeof 返回哪些数据类型"></a><strong>javascript 的 typeof 返回哪些数据类型</strong></h2><p>　　7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)<br><br/></p><h2 id="在css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理"><a href="#在css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理" class="headerlink" title="在css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理?"></a><strong>在css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理?</strong></h2><p>　　dns 缓存，cdn 缓存，浏览器缓存，服务器缓存。<br><br/></p><h2 id="列举-3-种强制类型转换和-2-种隐式类型转换"><a href="#列举-3-种强制类型转换和-2-种隐式类型转换" class="headerlink" title="列举 3 种强制类型转换和 2 种隐式类型转换"></a><strong>列举 3 种强制类型转换和 2 种隐式类型转换</strong></h2><p>　　强制（parseInt,parseFloat,Number）、隐式（+ -）<br><br/></p><h2 id="你对闭包的理解？优缺点？"><a href="#你对闭包的理解？优缺点？" class="headerlink" title="你对闭包的理解？优缺点？"></a><strong>你对闭包的理解？优缺点？</strong></h2><p>概念：闭包就是能够读取其他函数内部变量的函数。<br>三大特性：<br>　　1. 函数嵌套函数。<br>　　2. 函数内部可以引用外部的参数和变量。<br>　　3. 参数和变量不会被垃圾回收机制回收。<br>优点：<br>　　1. 希望一个变量长期存储在内存中。<br>　　2. 避免全局变量的污染。<br>　　3. 私有成员的存在。<br>缺点：<br>　　1. 常驻内存，增加内存使用量。<br>　　2. 使用不当会很容易造成内存泄露。<br>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"jack"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line">outer()(); <span class="comment">// jack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = sayHi(<span class="string">"xiaoming"</span>);</span><br><span class="line">test(); <span class="comment">// Hi! xiaoming</span></span><br></pre></td></tr></table></figure><p>　　虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。<br>　　但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会<strong>占用较多的内存</strong>，这也是一个副作用。<br><br/></p><h2 id="如何判断-NaN"><a href="#如何判断-NaN" class="headerlink" title="如何判断 NaN"></a><strong>如何判断 NaN</strong></h2><p>　　isNaN()方法<br><br/></p><h2 id="new-一个对象的过程中发生了什么"><a href="#new-一个对象的过程中发生了什么" class="headerlink" title="new 一个对象的过程中发生了什么"></a><strong>new 一个对象的过程中发生了什么</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建空对象；</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 2. 设置新对象的 constructor 属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的 prototype 对象；</span></span><br><span class="line">obj.__proto__ = ClassA.prototype;</span><br><span class="line"><span class="comment">// 3. 使用新对象调用函数，函数中的 this 被指向新实例对象：</span></span><br><span class="line">ClassA.call(obj); <span class="comment">//&#123;&#125;.构造函数();</span></span><br><span class="line"><span class="comment">// 4. 如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接返回该对象。</span></span><br></pre></td></tr></table></figure><br/><h2 id="for-in-和-for-of"><a href="#for-in-和-for-of" class="headerlink" title="for in 和 for of"></a><strong>for in 和 for of</strong></h2><p><strong>1. for in</strong></p><ul><li>一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行</li><li>不建议使用 for in 遍历数组，因为输出的顺序是不固定的</li><li>如果迭代的对象的变量值是 null 或者 undefined, for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是 null 或者 undefined</li></ul><p><strong>2. for of</strong></p><ul><li>for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Object</span>.create(s);<span class="comment">// 该方法创建一个新对象，使用现有的对象来提供新创建的对象的_proto_；</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> s1) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop); <span class="comment">//a b c</span></span><br><span class="line">  <span class="built_in">console</span>.log(s1[prop]); <span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> s1) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop); <span class="comment">//报错如下 Uncaught TypeError: s1 is not iterable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(s1)) &#123;  <span class="comment">//object.keys返回一个表示给定对象的所有可枚举属性的字符串数组</span></span><br><span class="line">  <span class="built_in">console</span>.log(prop); <span class="comment">// a b c</span></span><br><span class="line">  <span class="built_in">console</span>.log(s1[prop]); <span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="如何判断-JS-变量的一个类型（至少三种方式）"><a href="#如何判断-JS-变量的一个类型（至少三种方式）" class="headerlink" title="如何判断 JS 变量的一个类型（至少三种方式）"></a><strong>如何判断 JS 变量的一个类型（至少三种方式）</strong></h2><ul><li>typeof(判断引用类型时不准确，返回值只有object/function)</li><li>instanceof(判断一个实例是否属于某种类型)</li><li>constructor(<strong>对象才拥有的</strong>，从一个对象指向一个函数，含义是指向该对象的构造函数。所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数)</li><li>prototype(<strong>函数所独有的</strong>，含义是<strong>函数的原型对象</strong>，也就是这个函数所创建的实例的原型对象，作用是<strong>包含可以由特定类型的所有实例共享的属性和方法</strong>)<br/></li></ul><h2 id="for-in、Object-keys-和-Object-getOwnPropertyNames-对属性遍历有什么区别"><a href="#for-in、Object-keys-和-Object-getOwnPropertyNames-对属性遍历有什么区别" class="headerlink" title="for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别?"></a><strong>for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别?</strong></h2><p>　　1. for in 会遍历自身及原型链上的可枚举属性<br>　　2. Object.keys 会将对象自身的可枚举属性的 key 输出<br>　　3. Object.getOwnPropertyNames 会将自身所有的属性的 key 输出<br>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// parent继承自Object.prototype，有一个可枚举的属性a（enumerable:true）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//child 继承自 parent ，b可枚举，c不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// for in 会遍历自身及原型链上的可枚举属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Object.keys</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(child));</span><br><span class="line"><span class="comment">// ["b"]</span></span><br><span class="line"><span class="comment">// Object.keys 会将对象自身的可枚举属性的key输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Object.getOwnPropertyNames</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(child));</span><br><span class="line"><span class="comment">// ["b","c"]</span></span><br><span class="line"><span class="comment">// 会将自身所有的属性的key输出</span></span><br></pre></td></tr></table></figure><br/><h2 id="iframe-跨域通信和不跨域通信"><a href="#iframe-跨域通信和不跨域通信" class="headerlink" title="iframe 跨域通信和不跨域通信"></a><strong>iframe 跨域通信和不跨域通信</strong></h2><h3 id="不跨域通信"><a href="#不跨域通信" class="headerlink" title="不跨域通信"></a>不跨域通信</h3><p>主页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"myIframe"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"iframe"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"flexible.html"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">"500px"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">height</span>=<span class="string">"500px"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">fullscreen</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      alert(1111);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子页面 flexible.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    我是子页面</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// window.parent.fullScreens()</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">showalert</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      alert(222);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>主页面调取子页面的showalert方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myIframe.window.showalert();</span><br></pre></td></tr></table></figure></li><li>子页面调用主页面的fullscreen方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.fullScreens();</span><br></pre></td></tr></table></figure></li><li>js 在 iframe 子页面获取父页面元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.document.getElementById(<span class="string">"元素id"</span>);</span><br></pre></td></tr></table></figure></li><li>js 在父页面获取 iframe 子页面元素代码如下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames[<span class="string">"iframe_ID"</span>].document.getElementById(<span class="string">"元素id"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="跨域通信"><a href="#跨域通信" class="headerlink" title="跨域通信"></a>跨域通信</h3><p>使用<strong>postMessage</strong></p><p>子页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">"hello"</span>, <span class="string">"http://127.0.0.1:8089"</span>);</span><br></pre></td></tr></table></figure><p>父页面接收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br/><h2 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a><strong>如何判断一个对象是否为数组</strong></h2><ol><li>使用instanceof操作符<br>　　优点：可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点　<br>　　缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes</li><li>使用ECMAScript 5新增的Array.isArray()方法<br>　　优点：当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes<br>　　缺点：只能判别数组</li><li>使用Object.prototype上的原生toString()方法判断。<strong>(Object.prototype.toString.call())</strong><br>优点：这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined<br>缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]<br/></li></ol><h2 id="标签的-defer-和-asnyc-属性的作用以及二者的区别"><a href="#标签的-defer-和-asnyc-属性的作用以及二者的区别" class="headerlink" title=" 标签的 defer 和 asnyc 属性的作用以及二者的区别?"></a><strong><script> 标签的 defer 和 asnyc 属性的作用以及二者的区别?</strong></h2><pre><code>1. defer 和 async 的网络加载过程是一致的，都是**异步**执行。2. 区别在于加载完成之后什么时候执行，可以看出 defer 是文档所有元素解析完成之后才执行的。3. 如果存在多个 defer 脚本，那么它们是按照顺序执行脚本的，而 async，无论声明顺序如何，只要加载完成就立刻执行</code></pre><p>无论<script>标签是嵌入代码还是引用外部文件，只要不包含 defer 属性和 async 属性（这两个属性只对外部文件有效），浏览器会按照<script>的出现顺序对他们依次进行解析，也就是说，只有在第一个<script>中的代码执行完成之后，浏览器才会执行第二个<script>中的代码，并且在解析时，页面的处理会暂时停止。<br><br/></p><h2 id="你对松散类型的理解"><a href="#你对松散类型的理解" class="headerlink" title="你对松散类型的理解"></a><strong>你对松散类型的理解</strong></h2><p>　　JavaScript 中的变量为松散类型，所谓松散类型就是指当一个变量被申明出来就可以保存任意类型的值，就是不像 SQL 一样申明某个键值为 int 就只能保存整型数值，申明 varchar 只能保存字符串。一个变量所保存值的类型也可以改变，这在 JavaScript 中是完全有效的，只是不推荐。相比较于将变量理解为“盒子“，《JavaScript 编程精解》中提到应该将变量理解为“触手”，它不保存值，而是抓取值。这一点在当变量保存引用类型值时更加明显。<br><br/></p><h2 id="移动端-click-事件、touch-事件、tap-事件的区别"><a href="#移动端-click-事件、touch-事件、tap-事件的区别" class="headerlink" title="移动端 click 事件、touch 事件、tap 事件的区别"></a><strong>移动端 click 事件、touch 事件、tap 事件的区别</strong></h2><p>　　1. click 事件在移动端会有 200-300ms 的延迟，主要原因是苹果手机在设计时，考虑到用户在浏览网页时需要放大，所以，在用户点击的 200-300ms 之后，才触发 click，如果 200-300ms 之内还有 click，就会进行放大缩小。<br>　　2. touch 事件是针对触屏手机上的触摸事件。现今大多数触屏手机 webkit 内核提供了 touch 事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。其中包括：touchstart,touchmove,touchend,touchcancel 这四个事件，touchstart touchmove touchend 事件可以类比于 mousedown mouseover mouseup 的触发<br>　　3. tap 事件在移动端，代替 click 作为点击事件，tap 事件被很多框架（如 zepto）封装，来减少延迟问题， tap 事件不是原生的，是封装的<br>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tap</span>(<span class="params">ele, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 控制允许延迟的时间</span></span><br><span class="line">        delayTime = <span class="number">200</span>,</span><br><span class="line">    <span class="comment">// 记录是否移动，如果移动，则不触发tap事件</span></span><br><span class="line">        isMove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在touchstart时记录开始的时间</span></span><br><span class="line">    ele.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果touchmove事件被触发，则isMove为true</span></span><br><span class="line">    ele.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      isMove = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果touchmove事件触发或者中间时间超过了延迟时间，则返回，否则，调用回调函数。</span></span><br><span class="line">    ele.addEventListener(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isMove || (<span class="built_in">Date</span>.now() - startTime &gt; delayTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callback(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">  tap(btn, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'taped'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><br/><h2 id="JS-单线程还是多线程，如何显示异步操作"><a href="#JS-单线程还是多线程，如何显示异步操作" class="headerlink" title="JS 单线程还是多线程，如何显示异步操作"></a><strong>JS 单线程还是多线程，如何显示异步操作</strong></h2><p>JS 本身是单线程的，他是依靠浏览器完成的异步操作<br>步骤：<br>　　1. 主线程 执行 js 中所有的代码。<br>　　2. 主线程 在执行过程中发现了需要异步的任务后扔给浏览器（浏览器创建多个线程执行），并在  callback queue  中创建对应的回调函数（回调函数是一个对象，包含该函数是否执行完毕等）。<br>　　3. 主线程 已经执行完毕所有同步代码。开始监听  callback queque 一旦 浏览器 中某个线程任务完成将会改变回调函数的状态。主线程查看到某个函数的状态为已完成，就会执行该函数。<br><br/></p><h2 id="JavaScript-数组的函数-map-forEach-reduce-filter"><a href="#JavaScript-数组的函数-map-forEach-reduce-filter" class="headerlink" title="JavaScript 数组的函数 map/forEach/reduce/filter"></a><strong>JavaScript 数组的函数 map/forEach/reduce/filter</strong></h2><ol><li>map<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="comment">//作用：对数组进行遍历</span></span><br><span class="line"><span class="comment">//返回值：新的数组</span></span><br><span class="line"><span class="comment">// 是否改变：否</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> ret = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ret); <span class="comment">//[3,6,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[2,5,3,4]</span></span><br></pre></td></tr></table></figure></li><li>forEach<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="comment">// 作用：遍历数组的每一项</span></span><br><span class="line"><span class="comment">// 返回值：undefined</span></span><br><span class="line"><span class="comment">// 是否改变：否</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> ret = arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 2, 5, 3, 4</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ret); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[2,5,3,4]</span></span><br></pre></td></tr></table></figure></li><li>reduce<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 方法</span></span><br><span class="line"><span class="comment">// 作用：对数组进行迭代，然后两两进行操作，最后返回一个值</span></span><br><span class="line"><span class="comment">// 返回值：return出来的结果</span></span><br><span class="line"><span class="comment">// 是否改变：不会</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> ret = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ret); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li>filter<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter 过滤</span></span><br><span class="line"><span class="comment">// 作用： 筛选一部分元素</span></span><br><span class="line"><span class="comment">// 返回值： 一个满足筛选条件的新数组</span></span><br><span class="line"><span class="comment">// 是否改变原有数组：不会</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> ret = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ret); <span class="comment">//[5,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[2,5,3,4]</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="JS-块级作用域、变量提升"><a href="#JS-块级作用域、变量提升" class="headerlink" title="JS 块级作用域、变量提升"></a><strong>JS 块级作用域、变量提升</strong></h2><ol><li>块级作用域<br>　　JS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称 ES6)中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。</li><li>变量提升<br>　　如果变量声明在函数里面，则将变量声明提升到函数的开头；如果变量声明是一个全局变量，则将变量声明提升到全局作用域的开头<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">4&#123;</span><br><span class="line">44<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">44<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">4&#125;</span><br><span class="line">4<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">4<span class="comment">// 可见，通过var定义的变量可以跨块作用域访问到。</span></span><br><span class="line"></span><br><span class="line">4(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">44<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">44<span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">4&#125;)();</span><br><span class="line">4<span class="comment">// console.log(b); // 报错，</span></span><br><span class="line">4<span class="comment">// 可见，通过var定义的变量不能跨函数作用域访问到</span></span><br><span class="line"></span><br><span class="line">4<span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">44<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line">4<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">44<span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">4&#125;;</span><br><span class="line">4<span class="built_in">console</span>.log(i);<span class="comment">// 4   (循环结束i已经是4，所以此处i为4)</span></span><br><span class="line">4<span class="built_in">console</span>.log(d); <span class="comment">// 5</span></span><br><span class="line">4<span class="comment">// if语句和for语句中用var定义的变量可以在外面访问到，</span></span><br><span class="line">4<span class="comment">// 可见，if语句和for语句属于块作用域，不属于函数作用域。</span></span><br><span class="line"></span><br><span class="line">4&#123;</span><br><span class="line">44<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">44<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">44<span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">44&#123;</span><br><span class="line">444<span class="built_in">console</span>.log(a);<span class="comment">// 1子作用域可以访问到父作用域的变量</span></span><br><span class="line">444<span class="built_in">console</span>.log(b);<span class="comment">// 2子作用域可以访问到父作用域的变量</span></span><br><span class="line">444<span class="built_in">console</span>.log(c);<span class="comment">// 3子作用域可以访问到父作用域的变量</span></span><br><span class="line"></span><br><span class="line">444<span class="keyword">var</span> aa = <span class="number">11</span>;</span><br><span class="line">444<span class="keyword">let</span> bb = <span class="number">22</span>;</span><br><span class="line">444<span class="keyword">const</span> cc = <span class="number">33</span>;</span><br><span class="line">44&#125;</span><br><span class="line"></span><br><span class="line">44<span class="built_in">console</span>.log(aa);<span class="comment">// 11// 可以跨块访问到子 块作用域 的变量</span></span><br><span class="line">44<span class="comment">// console.log(bb);// 报错bb is not defined</span></span><br><span class="line">44<span class="comment">// console.log(cc);// 报错cc is not defined</span></span><br><span class="line">4&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="var、let、const-的区别"><a href="#var、let、const-的区别" class="headerlink" title="var、let、const 的区别"></a><strong>var、let、const 的区别</strong></h2><ol><li>var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。</li><li>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li><li>const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li><li>同一个变量只能使用一种方式声明，不然会报错<br>eg:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">4<span class="comment">// 块作用域</span></span><br><span class="line">4&#123;</span><br><span class="line">44<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">44<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">44<span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line">44<span class="comment">// c = 4; // 报错</span></span><br><span class="line"></span><br><span class="line">44<span class="comment">// let a = 'a';// 报错  注：是上面 var a = 1; 那行报错</span></span><br><span class="line">44<span class="comment">// var b = 'b';// 报错：本行报错</span></span><br><span class="line">44<span class="comment">// const a = 'a1';// 报错  注：是上面 var a = 1; 那行报错</span></span><br><span class="line">44<span class="comment">// let c = 'c';// 报错：本行报错</span></span><br><span class="line"></span><br><span class="line">44<span class="keyword">var</span> aa;</span><br><span class="line">44<span class="keyword">let</span> bb;</span><br><span class="line">44<span class="comment">// const cc; // 报错</span></span><br><span class="line">44<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">44<span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">44<span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line">44<span class="built_in">console</span>.log(aa); <span class="comment">// undefined</span></span><br><span class="line">44<span class="built_in">console</span>.log(bb); <span class="comment">// undefined</span></span><br><span class="line">4&#125;</span><br><span class="line">4<span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">4<span class="comment">// console.log(b); // 报错</span></span><br><span class="line">4<span class="comment">// console.log(c); // 报错</span></span><br><span class="line"></span><br><span class="line">4<span class="comment">// 函数作用域</span></span><br><span class="line">4(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">44<span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">44<span class="keyword">let</span> e = <span class="number">6</span>;</span><br><span class="line">44<span class="keyword">const</span> f = <span class="number">7</span>;</span><br><span class="line">44<span class="built_in">console</span>.log(d); <span class="comment">// 5</span></span><br><span class="line">44<span class="built_in">console</span>.log(e); <span class="comment">// 6  (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)</span></span><br><span class="line">44<span class="built_in">console</span>.log(f); <span class="comment">// 7  (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)</span></span><br><span class="line">4&#125;)();</span><br><span class="line">4<span class="comment">// console.log(d); // 报错</span></span><br><span class="line">4<span class="comment">// console.log(e); // 报错</span></span><br><span class="line">4<span class="comment">// console.log(f); // 报错</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="null-undefined的区别"><a href="#null-undefined的区别" class="headerlink" title="null/undefined的区别"></a><strong>null/undefined的区别</strong></h2><p>　　null: Null 类型，代表“空值"，代表一个空对象指针，使用 typeof 运算得到 “object"，所以你可以认为它是一个特殊的对象值。<br>　　undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined<br><br/></p><h2 id="重排与重绘的区别，什么情况下会触发？"><a href="#重排与重绘的区别，什么情况下会触发？" class="headerlink" title="重排与重绘的区别，什么情况下会触发？"></a><strong>重排与重绘的区别，什么情况下会触发？</strong></h2><ol><li>重排<br>　　浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。</li><li>重绘<br>　　重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</li><li>重绘和重排的关系<br>　　重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的</li><li>什么情况下会触发重排</li></ol><ul><li>页面渲染初始化时；（这个无法避免）</li><li>浏览器窗口改变尺寸；</li><li>元素尺寸改变时；</li><li>元素位置改变时；</li><li>元素内容改变时；</li><li>添加或删除可见的 DOM 元素时。</li></ul><ol start="5"><li>重排优化的方法</li></ol><ul><li>将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。</li><li>如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用）</li><li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</li><li>由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。</li><li>在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。<br/></li></ul><h2 id="jsonp-优缺点"><a href="#jsonp-优缺点" class="headerlink" title="jsonp 优缺点"></a><strong>jsonp 优缺点</strong></h2><p><strong>优点</strong></p><ul><li>它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略；</li><li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持</li><li>在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层终于分 开了。我提供的 jsonp 服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个 jsonp 服务。</li></ul><p><strong>缺点</strong></p><ul><li>它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求</li><li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。</li><li>jsonp 在调用失败的时候不会返回各种 HTTP 状态码。</li><li>缺点是安全性。假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么结果是什么？所有调用这个 jsonp 的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用 jsonp 的时候必须要保证使用的 jsonp 服务必须是安全可信的<br/></li></ul><h2 id="兼容各种浏览器版本的事件绑定"><a href="#兼容各种浏览器版本的事件绑定" class="headerlink" title="兼容各种浏览器版本的事件绑定"></a><strong>兼容各种浏览器版本的事件绑定</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">兼容低版本IE，ele为需要绑定事件的元素，</span></span><br><span class="line"><span class="comment">eventName为事件名（保持addEventListener语法，去掉on），fun为事件响应函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele, eventName, fun</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ele.addEventListener) &#123;</span><br><span class="line">    ele.addEventListener(eventName, fun, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ele.attachEvent(<span class="string">"on"</span> + eventNme, fun);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="split-和join-的区别"><a href="#split-和join-的区别" class="headerlink" title="split()和join()的区别"></a><strong>split()和join()的区别</strong></h2><p>　　join()：用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串<br>　　split()：用于把一个字符串通过指定的分隔符进行分隔成数组<br><br/></p><h2 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a><strong>new 操作符具体干了什么呢?</strong></h2><ol><li>创建一个新对象</li><li>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象</li><li>使用新对象调用函数，函数中的this被指向新实例对象</li><li>将初始化完毕的新对象地址，保存到等号左边的变量中<br/></li></ol><h2 id="call-和-apply-的含义和区别"><a href="#call-和-apply-的含义和区别" class="headerlink" title="call() 和 apply() 的含义和区别"></a><strong>call() 和 apply() 的含义和区别</strong></h2><p><strong>含义</strong></p><ul><li>call：调用一个对象的一个方法，用另一个对象替换当前对象，即改变调用函数中的this指向。例如：B.call(A, args1,args2);即 A 对象调用 B 对象的方法。</li><li>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用 B 对象的方法。</li></ul><p><strong>区别</strong></p><ul><li>call 可以传入多个参数；</li><li>apply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入<br/></li></ul><h2 id="sort排序原理"><a href="#sort排序原理" class="headerlink" title="sort排序原理"></a><strong>sort排序原理</strong></h2><p><strong>冒泡排序法</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br/></li></ul><h2 id="Zepto-的点透问题如何解决？"><a href="#Zepto-的点透问题如何解决？" class="headerlink" title="Zepto 的点透问题如何解决？"></a><strong>Zepto 的点透问题如何解决？</strong></h2><ol><li>github 上有个 fastclick 可以完美解决。引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">"load"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>或者使用require<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FastClick = <span class="built_in">require</span>(<span class="string">"fastclick"</span>);</span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body, options);</span><br></pre></td></tr></table></figure></li><li>用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cbFinish"</span>).on(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//很多处理比如隐藏什么的</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>延迟一定的时间(300ms+)来处理事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cbFinish"</span>).on(<span class="string">"tap"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//很多处理比如隐藏什么的</span></span><br><span class="line">  &#125;, <span class="number">320</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="如何判断当前脚本运行在浏览器还是-node-环境中？"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是 node 环境中？"></a><strong>如何判断当前脚本运行在浏览器还是 node 环境中？</strong></h2><p>　　通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中<br><br/></p><h2 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a><strong>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</strong></h2><ol><li>时间是300ms</li><li>因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。</li><li>推荐 fastclick.js</li></ol><br/><h2 id="Node-js-的适用场景？"><a href="#Node-js-的适用场景？" class="headerlink" title="Node.js 的适用场景？"></a><strong>Node.js 的适用场景？</strong></h2><p>　　RESTFUL API、实时聊天、客户端逻辑强大的单页 APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线 APP 等。<br><br/></p><h2 id="如何实现文件断点续传"><a href="#如何实现文件断点续传" class="headerlink" title="如何实现文件断点续传"></a><strong>如何实现文件断点续传</strong></h2><p>　　断点续传最核心的内容就是把文件<strong>切片</strong>然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。<br>　　首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。因此在文件开始上传之前，我们和服务器要有一个<strong>握手</strong>的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。<br>　　前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。<br>　　当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。<br>　　只要用 slice 方法就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packet = file.slice(start, end);</span><br></pre></td></tr></table></figure><p>　　参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块<br>　　在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+GitHub免费图床工具</title>
      <link href="/archives/b29ed1f0.html/"/>
      <url>/archives/b29ed1f0.html/</url>
      
        <content type="html"><![CDATA[<p>PicGo+<del>GitHub</del>Gitee让你的md文档起飞</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　我在前几篇博客中提到过，如何在markdown文件中插入图片。要么是按照markdown自己的方式，使用<strong>![]()</strong>的方式，要么使用Hexo提供的<strong>标签插件</strong>。但是他们的本质都是根据图片的path，从本地中取出。这种获取图片的方式存在一个问题，即当我们更换工作环境之后，我们除了要将md文档复制过去，还要连同本地图片一起附带过去。<br>　　虽然我们可以将图片一起上传到Github上，但是这种方式无法做到对图片的统一管理。因此<strong>图床</strong>这个工具就派上大用场。<strong>图床</strong>，即<strong>自动把本地图片转换成链接</strong>的一款工具。<br>　　这次我们介绍一款非常优秀的图床工具——<strong>PicGo</strong>，它支持微博、七牛云、腾讯云COS、又拍云、GitHub、阿里云OSS、SM.MS、Imgur等8种常用图床，功能强大、界面美观、简单易用。(<del>不过有时会突然冒出一些无厘头的bug</del>)<br>　　我使用的是PicGo+GitHub，若使用其他图床工具可自行探索。</p><p><strong>更新：用了一段时间，发现GitHub图床不太行|ω・），上传速度慢，而且经常失败。后来改用了Gitee，这篇文档就当了解吧，而且Gitee图床和GitHub图床配置差不多</strong></p><h2 id="创建GitHub图床"><a href="#创建GitHub图床" class="headerlink" title="创建GitHub图床"></a>创建GitHub图床</h2><h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p>　　前两步比较简单，注意创建仓库时，用README初始化仓库</p><h3 id="生成Token"><a href="#生成Token" class="headerlink" title="生成Token"></a>生成Token</h3><p>　　点击个人头像中的”Settings”，选中个人设置中的最下面一个按钮”Developer settings”<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403195822.png" alt=""><br>　　然后点击”Personal access tokens”，选中”Generate new token”，生成新的令牌<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403200339.png" alt=""><br>　　然后选择repo权限，名称随意即可<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403200546.png" alt=""></p><p>(令牌生成后，<strong>只会出现一次</strong>，请将它复制下来并保存好)</p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>　　首先，你需要到GitHub上的<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo项目</a>中下载可执行文件。若是mac系统，选择dmg后缀的文件，若是window，选择exe后缀的文件。</p><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200402224805.png" alt=""></p><p>　　GitHub上下载资源可能会遇到网页无法访问或下载速度过慢的问题，这时候我只能说一句：“<strong>迅雷</strong>是个好东西”(ಡωಡ) 安装了迅雷的同学，直接右键使用迅雷下载即可，速度非常快。</p><h3 id="PicGo上配置GitHub图床"><a href="#PicGo上配置GitHub图床" class="headerlink" title="PicGo上配置GitHub图床"></a>PicGo上配置GitHub图床</h3><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403201635.png" alt=""></p><p>　　仓库名：按照”用户名/仓库名”的格式，比如我的用户名为”hanabiicros”，仓库名为”cdn”<br>　　分支名：填”master”即可<br>　　Token：中将刚刚创建的令牌粘贴在这里即可<br>　　存储路径：随意<br>　　自定义域名：按照”https://raw.githubusercontent.com/用户名/仓库名/master”的格式填写，记住一定要加master，不加master会导致生成的图片链接无法访问到</p><h3 id="PicGo设置"><a href="#PicGo设置" class="headerlink" title="PicGo设置"></a>PicGo设置</h3><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403202652.png" alt=""></p><p>　　在设置中，可以点开日志文件，用来查看报错信息；可以修改快捷键等。建议开启<strong>时间戳重命名</strong>，这样可以防止上传两张同名图片而导致上传失败。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
            <tag> GitHub </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/archives/5d36ff15.html/"/>
      <url>/archives/5d36ff15.html/</url>
      
        <content type="html"><![CDATA[<p>初学markdown时踩过的坑…</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>　　不得不承认，在写这篇文章前，我对markdown的使用仅仅停留在如何显示标题、链接、图片以及如何加代码块。<br>　　一开始我以为这点就够了，不过当我编辑<strong>关于</strong>页面时，我ku了。由于网上教程有些坑，加之官网的描述不甚详细，因此我决定结合我的亲身试验，对其进行总结<br><br/></p><h2 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a><strong>Markdown介绍</strong></h2><p>　　Markdown 是一种<strong>轻量级标记语言</strong>，它允许人们使用易读易写的纯文本格式编写文档。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。<strong>(ps:摘自菜鸟教程)<del>个人感觉菜鸟教程更新的不够及时</del></strong><br><br/></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><p>　　标题有一级到六级之分，以’#’的数量区分。一个’#’是一级标题，两个’#’是二级标题，以此类推。不过这个说白了就是加粗、加大，html实现也挺容易的。</p><p>eg:</p><blockquote><p>### 三级标题  </p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>#### 四级标题</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4></blockquote><br/><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><p>　　<strong>斜体</strong>：将文字用<strong>一个</strong>*号包起来<br>　　<strong>加粗</strong>：将文字用<strong>两个</strong>*号包起来<br>　　<strong>斜体＆加粗</strong>：将文字用<strong>三个</strong>*号包起来<br>　　<strong>分隔线</strong>：用<strong>三个以上</strong>的’*‘、’-‘或’_’来建立一行分隔线<br>　　<strong>删除线</strong>：将文字用<strong>两个~</strong>号包起来<br>　　不过你也可以选择用html标签代替<del>(那你还用啥子markdown喽)</del></p><p>eg:</p><blockquote><p>*斜体*<br><em>斜体</em></p><p>**加粗**<br><strong>加粗</strong></p><p>***斜体&amp;粗体***<br><strong><em>斜体&amp;粗体</em></strong></p><p>~~删除线~~<br><del>删除线</del></p></blockquote><p><strong>分隔线</strong></p><pre><code>**** * *****</code></pre><hr><hr><hr><br/><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h2><p>　　缩进：在<strong>全角</strong>模式下用空格进行缩进<br>　　换行：行尾加上两个及以上的空格然后换行；或者直接硬换行，敲个回车键。若要中间空多行可以输入多个<strong>&lt;br/&gt;</strong><br><br/></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><p>　　需要引用文字，可以在其前加<strong>&gt;</strong>即可，而且支持嵌套</p><p>eg:</p><pre><code>&gt;这是引用的内容&gt;&gt;这是引用的内容的&apos;弟弟&apos;</code></pre><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容的’弟弟’</p></blockquote></blockquote><br/><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h2><p>　　要插入图片，形式如下：</p><pre><code>![alt](图片地址)![alt](图片地址 &quot;title属性&quot;)</code></pre><p>　　其中，’[]’中的<strong>alt</strong>填图片的说明文字，如”图1”之类的，”title属性”可加可不加，当鼠标hover时展示的信息</p><p>eg:</p><blockquote><p>![图1](wlop01.jpg)</p></blockquote><p><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403205514.jpg" alt="图1"><br><br/></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><p>　　插入链接，形式如下：</p><pre><code>[链接名称](链接地址)</code></pre><p>eg:</p><pre><code>[百度](https://www.baidu.com)</code></pre><blockquote><p><a href="https://www.baidu.com">百度</a></p></blockquote><br/><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h2><p>　　<strong>无序列表</strong><br>　　在每个列表项之前加’+’、’-‘或’*‘即可，而且列表项与之前的符号之间必须有<strong>一个空格</strong></p><p>eg:</p><pre><code>+ 列表1- 列表2* 列表3</code></pre><blockquote><ul><li>列表1</li></ul><ul><li>列表2</li></ul><ul><li>列表3</li></ul></blockquote><p>　　<strong>有序列表</strong><br>　　列表项前用数字&amp;’.’表示</p><p>eg:</p><pre><code>1. 列表12. 列表23. 列表3</code></pre><blockquote><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol></blockquote><p>　　<strong>列表嵌套</strong><br>　　在子列表的每一项前添加四个空格即可</p><p>eg:</p><pre><code>1.第一项    + 第一项嵌套的第一个元素    + 第一项嵌套的第二个元素</code></pre><blockquote><ol><li>第一项<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li></ol></blockquote><br/><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><p>　　表格用’|’来分隔不同的单元格，使用’-‘来分隔表头和其他行，而且’:-‘表示左对齐，’-:’表示右对齐，’:-:’表示居中对齐</p><p>eg:</p><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :--| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><p>　　额，应该是这个icrsus主题的设置，忽略了表格的竖线，不过也挺好看的<br><br/></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><p>　　<strong>单行代码</strong><br>　　代码之间用反引号包起来<br>eg：</p><pre><code>`int a = 10;`</code></pre><p>　　<code>int a = 10;</code></p><p>　　<strong>代码块</strong><br>　　代码之间用三个反引号包起来，且反引号独占一行<br>eg:</p><pre><code>(```)  code(```)</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">code</span></span><br></pre></td></tr></table></figure><p>　　那两个小括号是为了防止其转译多加的，实际使用应去掉</p><pre><code>写到这里，也就差不多了，markdown的基本使用都介绍了，我得去修改前几篇博客的样式了(ಥ_ಥ)</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题汇总——HTML篇</title>
      <link href="/archives/f0ff53b5.html/"/>
      <url>/archives/f0ff53b5.html/</url>
      
        <content type="html"><![CDATA[<p>汇集了各个大佬的成果～(￣▽￣～)~</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>　　最近许多大厂都开启了暑期实习生招聘，看着大佬们一个个offer拿到手软，真想<del>扇自己两巴掌</del>。因此菜菜的我决定对面试题进行汇总，并且对自己的不足之处进行巩固，有备无患嘛。(主要来源：<a href="https://github.com/yisainan/web-interview/">https://github.com/yisainan/web-interview/</a>)</p><h2 id="简述对HTML语义化的理解"><a href="#简述对HTML语义化的理解" class="headerlink" title="简述对HTML语义化的理解"></a><strong>简述对HTML语义化的理解</strong></h2><p>　　1. <strong>用正确的标签做正确的事情</strong><br>　　2. HTML语义化让页面的<strong>内容结构化，结构更清晰</strong>，便于对浏览器、搜索引擎解析；即使在没有样式CSS情况下也以一种文档格式显示，并且容易阅读<br>　　3. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，<strong>利于SEO</strong><br>　　4. 使阅读网页源码的人能更容易将网站分块，<strong>便于阅读、维护以及理解</strong><br><br/></p><h2 id="label标签作用以及使用方法"><a href="#label标签作用以及使用方法" class="headerlink" title="label标签作用以及使用方法"></a><strong>label标签作用以及使用方法</strong></h2><p>　　1. label标签用来定义表单控制间的关系，<strong>当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上</strong><br>　　2. 使用方法：<strong>一种是id绑定，一种是嵌套</strong><br>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"Name"</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"Name"</span> <span class="attr">id</span>=<span class="string">"Name"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"B"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><br/><h2 id="iframe框架有哪些优缺点"><a href="#iframe框架有哪些优缺点" class="headerlink" title="iframe框架有哪些优缺点"></a><strong>iframe框架有哪些优缺点</strong></h2><p><strong>优点：</strong><br>　　1. iframe能够原封不动的把嵌入的网页展示出来<br>　　2. 如果有多个网页引用iframe，那么只需修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷<br>　　3. 网页如果为了统一风格，header和footer都一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性<br>　　4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe解决</p><p><strong>缺点：</strong><br>　　1. 框架结构中出现各种滚动条<br>　　2. iframe会阻塞主页面的Onload事件，拖慢网页加载<br>　　3. 搜索引擎的检索程序无法解读这种页面，不利于SEO<br>　　4. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</p><br/><h2 id="HTML与XHTML有什么区别，推荐哪个"><a href="#HTML与XHTML有什么区别，推荐哪个" class="headerlink" title="HTML与XHTML有什么区别，推荐哪个"></a><strong>HTML与XHTML有什么区别，推荐哪个</strong></h2><p>　　推荐使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：<br>　　1. XHTML中所有的标签必须闭合<br>　　2. XHTML所有标签都必须使用小写<br>　　3. 所有的XML标记都必须合理嵌套<br>　　4. 所有的参数值都必须用引号””括起来<br>　　5. 把所有&lt;和&amp;特殊符号用编码表示<br>　　6. 给所有属性赋值<br>　　7. 不要在注释内容中使用”–”<br>　　8. 图片必须使用说明文字<br>　　ps:<del>HTML<strong>元素</strong>以开始标签起始，以结束标签终止</del><br><br/></p><h2 id="HTML5的form如何关闭自动填充功能"><a href="#HTML5的form如何关闭自动填充功能" class="headerlink" title="HTML5的form如何关闭自动填充功能"></a><strong>HTML5的form如何关闭自动填充功能</strong></h2><p>　　将不想要自动完成的form或input设置为<strong>autocomplete=off</strong><br><br/></p><h2 id="title与h1、b与strong、i与em的区别"><a href="#title与h1、b与strong、i与em的区别" class="headerlink" title="title与h1、b与strong、i与em的区别"></a><strong>title与h1、b与strong、i与em的区别</strong></h2><p>　　1. title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，SEO权重高于h1；h1概括的是文章的主题，一个页面最好只用一个h1<br>　　2. b是为了加粗而加粗，strong是为了标明重点而加粗<br>　　3. i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i重视的多<br><br/></p><h2 id="描述下SEO中的TDK"><a href="#描述下SEO中的TDK" class="headerlink" title="描述下SEO中的TDK"></a><strong>描述下SEO中的TDK</strong></h2><p>　　在SEO中，所谓的TDK就是title(标题标签)、description(描述标签)、keywords(关键词标签)这三个标签<br><br/></p><h2 id="HTML文件头中的DOCTYPE的作用"><a href="#HTML文件头中的DOCTYPE的作用" class="headerlink" title="HTML文件头中的DOCTYPE的作用"></a><strong>HTML文件头中的DOCTYPE的作用</strong></h2><p>　　1. 告知浏览器，文档使用的是哪种HTML或XHTML规范<br>　　2. 告诉浏览器按照何种规范(DTD)解析页面，若没有DOCTYPE声明，那么浏览器将按照自己的方式解析渲染页面<br><br/></p><h2 id="简述一下src和href区别"><a href="#简述一下src和href区别" class="headerlink" title="简述一下src和href区别"></a><strong>简述一下src和href区别</strong></h2><p>　　src用于引用资源，替换当前元素；href用于在当前文档和引用资源之间确立联系。<br>　　<strong>href:</strong><br>　　href标识超文本引用，用在link和a等标签上，是在当前元素和引用资源之间建立联系。若在文档中添加href，浏览器会识别该文档为CSS文件，就会并行下载资源并且不会停止对当前文档的处理。因此<strong>建议使用link方式加载CSS，而不是使用@import方式</strong><br>　　<strong>src:</strong><br>　　src表示引用资源，替换当前元素，用在img,script,iframe上。当浏览器解析到src，会暂停其他资源的下载和处理(图片不会)，直到将该资源加载、编译、执行完毕，类似于将所有资源引用到当前内容。因此<strong>建议把js脚本放在底部而不是头部</strong><br><br/></p><h2 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a><strong>严格模式与混杂模式</strong></h2><p>　　严格模式：以浏览器支持的最高标准运行<br>　　混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为<br><br/></p><h2 id="对WEB标准以及W3C的理解"><a href="#对WEB标准以及W3C的理解" class="headerlink" title="对WEB标准以及W3C的理解"></a><strong>对WEB标准以及W3C的理解</strong></h2><p>　　WEB标准简单来说可以分为<strong>结构、表现和行为</strong>。其中结构主要由HTML标签组成。表现即指CSS样式表。行为指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要由js组成<br>　　WEB标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使得这三者的界限并不那么清晰<br>　　W3C对WEB标准提出了规范化的要求，也就是在实际编程中的一些代码规范。包含如下几点：<br>　　1. 对于结构要求：<br>　　　　1. 标签字母要小写<br>　　　　2. 标签要闭合<br>　　　　3. 标签不允许随意嵌套<br>　　2. 对于CSS和js要求：<br>　　　　1. 尽量使用外联CSS样式表和js脚本。将结构、表现和行为分为三块。同时提高页面渲染速度，提高用户体验。<br>　　　　2. 样式尽量少用行间样式表，使结构和表现分离，标签的id和class等属性命名要做到见文知意，标签越少，加载越快，代码维护简单，便于改版<br>　　　　3. 不需要变动页面内容，便可提供打印版本而不需要复制内容<br><br/></p><h2 id="列举IE与其他浏览器不一样的特性"><a href="#列举IE与其他浏览器不一样的特性" class="headerlink" title="列举IE与其他浏览器不一样的特性"></a><strong>列举IE与其他浏览器不一样的特性</strong></h2><p>　　1. IE的排版引擎是Trident<br>　　2. Trident内核曾经几乎与W3C标准脱节<br>　　3. Trident内核的大量bug等安全性问题没有得到及时解决<br>　　4. js方面有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等<br>　　5. CSS方面，也有自己独立的处理方式，例如设置透明，低版本IE中使用滤镜的方式<br><br/></p><h2 id="前端页面由哪三层构成，及作用"><a href="#前端页面由哪三层构成，及作用" class="headerlink" title="前端页面由哪三层构成，及作用"></a><strong>前端页面由哪三层构成，及作用</strong></h2><p>　　分别是结构层、表示层、行为层<br>　　<strong>结构层：</strong><br>　　由HTML或XHTML之类的标记语言负责创建。标签对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。<br>　　<strong>表示层：</strong><br>　　由CSS负责创建，CSS对”如何显示有关内容”的问题做出了回答<br>　　<strong>行为层：</strong><br>　　负责回答”内容应该如何对事件做出反应”这一问题，这是javascript和DOM主宰的领域<br><br/></p><h2 id="网页验证码是干嘛的"><a href="#网页验证码是干嘛的" class="headerlink" title="网页验证码是干嘛的"></a><strong>网页验证码是干嘛的</strong></h2><p>　　1. 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水<br>　　2. 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试<br><br/></p><h2 id="为什么用多个域名存储网站资源更有效"><a href="#为什么用多个域名存储网站资源更有效" class="headerlink" title="为什么用多个域名存储网站资源更有效"></a><strong>为什么用多个域名存储网站资源更有效</strong></h2><p>　　1. CDN缓存更方便 <del>CDN边缘节点缓存主要解决网络延迟问题</del><br>　　2. 突破浏览器并发限制<br>　　3. 节约cookie带宽<br>　　4. 节约主域名的连接数，优化页面响应速度<br>　　5. 防止不必要的安全问题<br><br/></p><h2 id="页面可见性API有哪些用途"><a href="#页面可见性API有哪些用途" class="headerlink" title="页面可见性API有哪些用途"></a><strong>页面可见性API有哪些用途</strong></h2><p>　　<strong>页面可见性：</strong>就是对于用户来说，页面是显示还是隐藏。所谓显示的页面，就是我们正在看的页面，隐藏的页面，就是我们没有看到的页面。因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的。<br>　　API有，<strong>doucument.hidden</strong>就返回一个布尔值，如果是true，表示页面可见，false则表示页面隐藏。不同页面之间来回切换，触发<strong>visibilitychange</strong>事件。还有一个<strong>document.visibilityState</strong>，表示页面所处的状态，取值：visible,hidden等</p><p>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden)&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"hidden"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"visibile"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br/><h2 id="Quirks模式是什么，和Standards模式的区别"><a href="#Quirks模式是什么，和Standards模式的区别" class="headerlink" title="Quirks模式是什么，和Standards模式的区别"></a><strong>Quirks模式是什么，和Standards模式的区别</strong></h2><p>　　1. 以ie6为例，如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之间的布局方式。这就是Quirks模式(怪异模式)<br>　　2. 区别：总体会有布局、样式解析和脚本执行三个方面的区别<br>eg:</p><pre><code>1. 在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks  模式下，IE 的宽度和高度还包含了 padding 和 border2. 设置行内元素的高宽：在 Standards 模式下，给&lt;span&gt;等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效3. 使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效</code></pre><br/><h2 id="div-css的布局较table布局有什么优点"><a href="#div-css的布局较table布局有什么优点" class="headerlink" title="div+css的布局较table布局有什么优点"></a><strong>div+css的布局较table布局有什么优点</strong></h2><p>　　1. 改版的时候更方便，只要改css文件<br>　　2. 页面加载速度更快、结构化清晰、页面显示简洁<br>　　3. 表现与结构相分离<br>　　4. SEO更友好，检索的排名更容易靠前<br><br/></p><h2 id="描述一下渐进增强和优雅降级之间的不同"><a href="#描述一下渐进增强和优雅降级之间的不同" class="headerlink" title="描述一下渐进增强和优雅降级之间的不同"></a><strong>描述一下渐进增强和优雅降级之间的不同</strong></h2><p>　　<strong>渐进增强：</strong>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果交互等改进和追加功能达到更好的用户体验。<br>　　<strong>优雅降级：</strong>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容<br>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级意味着往回看，而渐进增强则意味着朝前看，同时保证其根基处于安全地带。<br><br/></p><h2 id="谈一下对网页标准和标准制定机构重要性的理解"><a href="#谈一下对网页标准和标准制定机构重要性的理解" class="headerlink" title="谈一下对网页标准和标准制定机构重要性的理解"></a><strong>谈一下对网页标准和标准制定机构重要性的理解</strong></h2><p>　　降低开发难度及开发成本，减少各种Bug、安全问题，提高网站易用性<br><br/></p><h2 id="什么是微格式"><a href="#什么是微格式" class="headerlink" title="什么是微格式"></a><strong>什么是微格式</strong></h2><p>　　微格式是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式<br>优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示<br><br/></p><h2 id="如何实现一个圆形的可点击区域"><a href="#如何实现一个圆形的可点击区域" class="headerlink" title="如何实现一个圆形的可点击区域"></a><strong>如何实现一个圆形的可点击区域</strong></h2><ol><li>border-radius。采用CSS3的圆角属性</li><li>通过事件坐标来实现<br>eg.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对目标元素target的圆形区域进行一个点击事件绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindClickOnCircleArea</span>(<span class="params">target, callback</span>) </span>&#123;</span><br><span class="line">  target.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target中心点的坐标</span></span><br><span class="line">    <span class="keyword">var</span> x1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">var</span> y1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件源坐标</span></span><br><span class="line">    <span class="keyword">var</span> x2 = e.offsetX;</span><br><span class="line">    <span class="keyword">var</span> y2 = e.offsetY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验是否在圆形点击区，在的话就执行callback回调</span></span><br><span class="line">    <span class="comment">// 计算事件触发点与target中心的位置</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(x2 - x1, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(y2 - y1, <span class="number">2</span>)));</span><br><span class="line">    <span class="comment">// 通过半径进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">"死鬼，跑哪去啊，你老婆我是黄皮肤还是白皮肤都分不清了吗"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">bindClickOnCircleArea(box, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"老婆，你让我好找啊，呜呜呜"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>通过map加area<br>eg.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../imgs/test.jpg"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">usemap</span>=<span class="string">"#Map"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--img的usemap属性和map的name属性以及id属性相关联--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"Map"</span> <span class="attr">id</span>=<span class="string">"Map"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span></span></span><br><span class="line"><span class="tag">    <span class="attr">shape</span>=<span class="string">"circle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">coords</span>=<span class="string">"100,100,100"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">target</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><br/></li></ol><h2 id="前端需要注意哪些SEO"><a href="#前端需要注意哪些SEO" class="headerlink" title="前端需要注意哪些SEO"></a><strong>前端需要注意哪些SEO</strong></h2><p>　　1. <strong>合理的 title、description、keywords</strong>：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可<br>　　2. <strong>语义化的HTML代码</strong>，符合 W3C 规范：语义化代码让搜索引擎容易理解网页<br>　　3. <strong>重要内容HTML代码放在最前</strong>：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br>　　4. <strong>重要内容不要用 js 输出</strong>：爬虫不会执行 js 获取内容<br>　　5. <strong>少用 iframe</strong>：搜索引擎不会抓取 iframe 中的内容<br>　　6. 非装饰性图片必须加 alt，即说明文字<br>　　7. <strong>提高网站速度</strong>：网站速度是搜索引擎排序的一个重要指标<br><br/></p><h2 id="html5有哪些新特性，移除了哪些元素"><a href="#html5有哪些新特性，移除了哪些元素" class="headerlink" title="html5有哪些新特性，移除了哪些元素"></a><strong>html5有哪些新特性，移除了哪些元素</strong></h2><p>新特性：<br>　　1. 拖拽释放(Drag and drop) API<br>　　2. 语义化更好的内容标签（header,nav,footer,aside,article,section）<br>　　3. 音频、视频 API(audio,video)<br>　　4. 画布(Canvas) API<br>　　5. 地理(Geolocation) API<br>　　6. 本地离线存储<strong>localStorage</strong>长期存储数据，浏览器关闭后数据不丢失；<br>　　7. sessionStorage的数据在浏览器关闭后自动删除<br>　　8. 表单控件，calendar、date、time、email、url、search<br>　　9. 新的技术 webworker, websocket, Geolocation<br>移除的元素：<br>　　1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>　　2. 对可用性产生负面影响的元素：frame，frameset，noframes；<br><br/></p><h2 id="html的离线储存如何使用，解释一下工作原理"><a href="#html的离线储存如何使用，解释一下工作原理" class="headerlink" title="html的离线储存如何使用，解释一下工作原理"></a><strong>html的离线储存如何使用，解释一下工作原理</strong></h2><p>　　在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>原理：HTML5 的离线存储是基于一个新建的<strong>.appcache 文件的缓存机制</strong>(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。<br>使用方法：<br>　　只要在头部加一个<strong>manifest属性</strong>即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"cache.manifest"</span>&gt;</span></span><br><span class="line">  ...　　</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　然后在cache.manifest文件的书写方式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CACHE</span> <span class="string">MANIFEST</span></span><br><span class="line"><span class="comment">#v0.11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CACHE</span>:<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">js/app.js</span></span><br><span class="line"><span class="attr">css/style.css</span></span><br><span class="line"></span><br><span class="line"><span class="attr">NETWORK</span>:<span class="string"></span></span><br><span class="line"><span class="attr">resourse/logo.png</span></span><br><span class="line"></span><br><span class="line"><span class="attr">FALLBACK</span>:<span class="string"></span></span><br><span class="line"><span class="meta">/</span> <span class="string">/offline.html</span></span><br></pre></td></tr></table></figure><p>离线存储的 manifest 一般由三个部分组成:<br>　　1. CACHE:表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。<br>　　2. NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说<strong>CACHE的优先级更高</strong>。<br>　　3. FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html。<br><br/></p><h2 id="浏览器是如何对HTML5的离线储存资源进行管理和加载的"><a href="#浏览器是如何对HTML5的离线储存资源进行管理和加载的" class="headerlink" title="浏览器是如何对HTML5的离线储存资源进行管理和加载的"></a><strong>浏览器是如何对HTML5的离线储存资源进行管理和加载的</strong></h2><p>　　在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。<br><br/></p><h2 id="HTML全局属性有哪些"><a href="#HTML全局属性有哪些" class="headerlink" title="HTML全局属性有哪些"></a><strong>HTML全局属性有哪些</strong></h2><p>　　1. accesskey:设置快捷键，提供快速访问元素如’accesskey=a’在 windows 下的 firefox 中按 alt + shift + a 可激活元素，若是Chrome则是 alt + a<br>　　2. class:为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素<br>　　3. <strong>(new)</strong>contenteditable: 指定元素内容是否可编辑<br>　　4. <strong>(new)</strong>contextmenu: 自定义鼠标右键弹出菜单内容(<strong>仅Firefox支持</strong>)<br>　　5. <strong>(new)</strong>data-*: 为元素增加自定义属性<br>　　6. dir: 设置元素文本方向 ‘dir=”rtl”‘(文本从右到左)<br>　　7. <strong>(new)</strong>draggable: 设置元素是否可拖拽<br>　　8. <strong>(new)</strong>dropzone: 设置元素拖放类型： copy, move, link(<strong>没有主流浏览器支持</strong>)<br>　　9. <strong>(new)</strong>hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果<br>　　10. id: 元素 id，文档内唯一<br>　　11. lang: 元素内容的的语言<br>　　12. <strong>(new)</strong>spellcheck: 是否启动拼写和语法检查<br>　　13. style: 行内 css 样式<br>　　14. tabindex: 设置元素可以获得焦点，通过 tab 可以导航<br>　　15. title: 元素相关的建议信息<br>　　16. <strong>(new)</strong>translate: 元素和子孙节点内容是否需要本地化(<strong>没有主流浏览器支持</strong>)<br><br/></p><h2 id="Canvas和SVG的区别"><a href="#Canvas和SVG的区别" class="headerlink" title="Canvas和SVG的区别"></a><strong>Canvas和SVG的区别</strong></h2><p><strong>Canvas：</strong>通过 Javascript 来绘制 2D 图形。是逐像素进行渲染的。其位置发生改变，会重新进行绘制<br><strong>SVG：</strong>一种使用 XML 描述的 2D 图形的语言 SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。<br><strong>区别：</strong><br>Canvas<br>　　1. 依赖分辨率<br>　　2. 不支持事件处理器<br>　　3. 弱的文本渲染能力<br>　　4. 能够以 .png 或 .jpg 格式保存结果图像<br>　　5. 最适合图像密集型的游戏，其中的许多对象会被频繁重绘<br>SVG<br>　　1. 不依赖分辨率<br>　　2. 支持事件处理器<br>　　3. 最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>　　4. 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>　　5. 不适合游戏应用<br><br/></p><h2 id="HTML5为什么只需要写"><a href="#HTML5为什么只需要写" class="headerlink" title="HTML5为什么只需要写"></a><strong>HTML5为什么只需要写<!DOCTYPE HTML></strong></h2><p>　　HTML4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于<strong>SGML</strong>。而 HTML5不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML是标准通用标记语言,简单的说，就是比 HTML,XML 更老的标准，这两者都是由SGML发展而来的。但是，HTML5不是的。<br><br/></p><h2 id="meta-viewport原理是什么"><a href="#meta-viewport原理是什么" class="headerlink" title="meta viewport原理是什么"></a><strong>meta viewport原理是什么</strong></h2><p>　　meta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放<br>　　<strong>viewport的原理</strong>：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户<br><strong>Viewport属性值</strong><br>　　1. width 设置 layout viewport 的宽度，为一个正整数，或字符串”width-device”<br>　　2. initial-scale 设置页面的初始缩放值，为一个数字，可以带小数<br>　　3. minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数<br>　　4. maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数<br>　　5. height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用<br>　　6. user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了<br><br/></p><h2 id="对web标准、可用性、可访问性的理解"><a href="#对web标准、可用性、可访问性的理解" class="headerlink" title="对web标准、可用性、可访问性的理解"></a><strong>对web标准、可用性、可访问性的理解</strong></h2><p><strong>可用性(Usability)</strong>：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。<br><strong>可访问性(Accessibility)</strong>：Web 内容对于残障用户的可阅读和可理解性<br><strong>可维护性(Maintainability)</strong>：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。<br><br/></p><h2 id="HTML5引入哪些新的表单元素、类型和属性"><a href="#HTML5引入哪些新的表单元素、类型和属性" class="headerlink" title="HTML5引入哪些新的表单元素、类型和属性"></a><strong>HTML5引入哪些新的表单元素、类型和属性</strong></h2><p>表单元素：<br>　　1. &lt;datalist&gt;规定输入域的选项列表<br>　　2. &lt;keygen&gt;规定用于表单的密钥对生成器字段<br>　　3. &lt;output&gt;用于不同类型的输出<br>表单类型:<br>　　date month week time number range email url color search datetime<br>表单属性：<br>　　<strong>input:</strong><br>　　　　autocomplete(规定 form 或 input 域应该拥有自动完成功能)<br>　　　　autofocus(规定在页面加载时，域自动地获得焦点)<br>　　　　form(规定输入域所属的一个或多个表单)<br>　　　　formaction(用于描述表单提交的URL地址,会覆盖&lt;form&gt; 元素中的action属性)<br>　　　　formenctype(描述了表单提交到服务器的数据编码)<br>　　　　formmethod(定义了表单提交的方式,覆盖了 &lt;form&gt; 元素的 method 属性)<br>　　　　formnovalidate<br>　　　　formtarget<br>　　　　height 与 width(规定用于 image 类型的 &lt;input&gt; 标签的图像高度和宽度)<br>　　　　list(规定输入域的 datalis)<br>　　　　min 与 max(用于为包含数字或日期的 input 类型规定限定)<br>　　　　multiple(规定&lt;input&gt; 元素中可选择多个值)<br>　　　　pattern(描述了一个正则表达式用于验证 &lt;input&gt; 元素的值)<br>　　　　placeholder<br>　　　　required(规定必须在提交之前填写输入域)<br>　　　　step(为输入域规定合法的数字间隔)<br>　　<strong>form:</strong><br>　　　　autocomplete<br>　　　　novalidate(规定在提交表单时不应该验证 form 或 input 域)<br><br/></p><h2 id="HTML5存储类型有什么区别"><a href="#HTML5存储类型有什么区别" class="headerlink" title="HTML5存储类型有什么区别"></a><strong>HTML5存储类型有什么区别</strong></h2><p><strong>cookies,seesionStorage,localStorage</strong><br>　　共同点：都是保存到浏览器端，都是同源<br>　　区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大；seesionStroage在窗口关闭前有效，不在不同浏览器窗口共享。localStroage始终有效，永久数据，所有同源窗口共享；cookie在过期前有效，所有同源窗口共享<br><br/></p><h2 id="iframe的作用"><a href="#iframe的作用" class="headerlink" title="iframe的作用"></a><strong>iframe的作用</strong></h2><p>　　iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载<br><strong>优点：</strong><br>　　1. 便于修改，模拟分离，像一些信息管理系统会用到<br>　　2. 但现在基本不推荐使用。除非特殊需要，一般不推荐使用<br><strong>缺点：</strong><br>　　1. iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级<br>　　2. iframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。<br>　　3. iframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。<br><br/></p><h2 id="link标签和script标签的放置位置"><a href="#link标签和script标签的放置位置" class="headerlink" title="link标签和script标签的放置位置"></a><strong>link标签和script标签的放置位置</strong></h2><p><strong>&lt;link&gt;放在&lt;head&gt;中:</strong>把&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容<br><strong>&lt;script&gt;标签恰好放在&lt;/body&gt;之前</strong>:脚本在下载和执行期间会阻止 HTML 解析。把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户<br><strong>例外情况</strong>：当你的脚本里包含document.write()时<br><br/></p><h2 id="什么是渐进式渲染"><a href="#什么是渐进式渲染" class="headerlink" title="什么是渐进式渲染"></a><strong>什么是渐进式渲染</strong></h2><p>　　渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术<br>eg:<br>　　1. 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像<br>　　2. 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容<br>　　3. 异步加载 HTML片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器<br><br/></p><h2 id="DOM和BOM的区别"><a href="#DOM和BOM的区别" class="headerlink" title="DOM和BOM的区别"></a><strong>DOM和BOM的区别</strong></h2><p><strong>DOM</strong>:文档对象模型，DOM 是为了操作文档出现的 API，document 是其的一个对象。DOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容<br><strong>BOM</strong>:浏览器对象模型,BOM 是为了操作浏览器出现的 API，window 是其的一个对象<br>window 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象<br><br/></p><h2 id="img上的title和alt"><a href="#img上的title和alt" class="headerlink" title="img上的title和alt"></a><strong>img上的title和alt</strong></h2><p>　　title 指图片的信息，alt 指图片不显示时显示的文字<br><br/></p><h2 id="100×100的canvas占多少内存"><a href="#100×100的canvas占多少内存" class="headerlink" title="100×100的canvas占多少内存"></a><strong>100×100的canvas占多少内存</strong></h2><p>　　40,000 bytes即4×100×100</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo创建博客(进阶篇)</title>
      <link href="/archives/413d9fe2.html/"/>
      <url>/archives/413d9fe2.html/</url>
      
        <content type="html"><![CDATA[<p>这是对基础篇的补充，方便了解Hexo，并对其进行个性化配置</p><a id="more"></a><h2 id="Hexo基本配置"><a href="#Hexo基本配置" class="headerlink" title="Hexo基本配置"></a><strong>Hexo基本配置</strong></h2><h3 id="config-yml配置文件"><a href="#config-yml配置文件" class="headerlink" title="_config.yml配置文件"></a>_config.yml配置文件</h3><p>　　该文件中是整个’Hexo’框架的配置文件，下面对其部分参数信息进行描述.</p><h4 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">icrosの小窝</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'帅斌的博客'</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Yaobin</span> <span class="string">Zhang</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;title&apos;：网站的标题-&apos;subtitle&apos;：网站的副标题-&apos;description&apos;：网站的描述，用于SEO-&apos;keywords&apos;：网站的关键词-&apos;author&apos;：网站的作者-&apos;language&apos;：网站所使用的语言，默认是en，你可以改为&apos;zh-CN&apos;简体中文-&apos;timezone&apos;：网站的时区，默认使用你电脑的时区</code></pre><br/><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://hanabiicros.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;url&apos;：网址，如果你的网站是放在子路径下，则将其设置为&apos;http://yoursite.com/child&apos;-&apos;root&apos;：网站的根目录-&apos;permalink&apos;：文章的永久链接格式，即发布的文章在网站下生成的路径格式，默认是&apos;yoursite.com/year/month/day/title&apos;-&apos;pretty_urls&apos;：改写permalink的值来美化URL-&apos;pretty_urls.trailing_index&apos;：是否在永久链接中保留尾部的index.html-&apos;pretty_urls.trailing_html&apos;：是否在永久链接中保留尾部的.html</code></pre><br/><h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure><p>　　主要配置了各个文件夹的存放位置，另外’skip_render’表示跳过指定文件的渲染，即你可以使用自己的样式，一般默认即可。<br><br/></p><h4 id="home-page-setting"><a href="#home-page-setting" class="headerlink" title="home page setting"></a>home page setting</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;index_generator.path&apos;：指明博客主页的根路径-&apos;index_generator.per_page&apos;：每页显示的最多文章数-&apos;index_generator.order_by&apos;：文章的排序方式</code></pre><br/><h4 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">icarus</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;theme&apos;：当前主题名称-&apos;theme_config&apos;：主题的配置文件，会覆盖主题目录下的&apos;_config.yml&apos;中的配置-&apos;deploy&apos;：部署部分的设置</code></pre><p>　　其他配置默认即可，详细信息可见<a href="https://hexo.io/zh-cn/docs">官方文档</a><br><br/></p><h2 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a><strong>Hexo基本操作</strong></h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>　　‘基础篇’中讲了用如下命令，新建一篇文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">'title'</span></span><br></pre></td></tr></table></figure><p>　　除了新建文章外，还可以新建页面’page’或者草稿’draft’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">'title'</span></span><br><span class="line">hexo new draft <span class="string">'title'</span></span><br></pre></td></tr></table></figure><p>　　其中新建的页面’page’的’title’，和你在导航栏中自定义的路径’/title’相匹配的。即点击导航栏的’title’按钮，会定位到这个页面中。<del>(ps:当初看官方文档的时候看到了这里，不过没仔细看，结果在’关于’页面卡了好久，不知道怎么加这个页面。han(lll￢ω￢))</del><br><br/></p><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>　　Front-matter是每个post中最上方以’—‘分割的区域，指定个别文件的变量</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">基于Hexo创建博客(进阶篇)</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-26</span> <span class="number">22</span><span class="string">:08:31</span></span><br><span class="line"><span class="attr">thumbnail:</span> <span class="string">/images/wc01.jpg</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span>            <span class="comment">#标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">技术</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><pre><code>-&apos;title&apos;：标题-&apos;date&apos;：建立日期-&apos;updated&apos;：更新日期-&apos;tags&apos;：标签，网站会根据每篇文章的标签进行归类-&apos;categories&apos;：分类，同样网站会根据每篇文章所属分类进行归类-&apos;comments&apos;：开启文章的评论功能，不加默认开启-&apos;permalink&apos;：覆盖文章的网址</code></pre><p>　　另外’thumbnail’和’toc’是’icarus’主题特有的。<br><br/></p><h3 id="资源插入"><a href="#资源插入" class="headerlink" title="资源插入"></a>资源插入</h3><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>　　在Hexo 2之前，许多人是推荐安装’hexo-asset-image’，该插件貌似是解决了因常规的md语法和相对路径引用资源的方式造成在存档页和主页显示不正确的问题<del>(ps:因为我是一上手就直接体验icarus主题，因而没遇到这个问题，况且我还是最新版的Hexo呢)</del></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">https://github.com/CodeFalling/hexo-asset-image</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><p>　　然后在博客根目录下的’_config.yml’文件中将’post_asset_folder’属性设置为true，这样在每次创建新的文章时，他会自动在同目录下创建一个同名的文件夹，该文件夹用于存放与文章相关的资源。<br>　　接着用传统的md形式就能实现图片的插入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">![title](xxx.jpg/png)</span></span><br></pre></td></tr></table></figure><p>　　但是我在官方提供的插件库中，并未找到’hexo-asset-image’，只有’hexo-asset’，不过提供的功能大致是一样的。<br><br/></p><h4 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h4><p>　　除了上述方法，在Hexo 3中，官方提供了名为’标签插件’的东东</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">asset_path</span> <span class="string">slug</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">asset_img</span> <span class="string">slug</span> <span class="string">[title]</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">asset_link</span> <span class="string">slug</span> <span class="string">[title]</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure><p>　　像这样也可以实现路径、图片、链接的插入，当然这个功能是很强大的，官方提供了’引用块’、’代码块’、’Image’、’Youtube’等的插入方式。<br>对于码农而言，主要用到的还是代码块的插入。一般使用，只需指明使用的语言’lang:’即可，而且它默认显示行号。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">codeblock</span> <span class="string">[title]</span> <span class="string">[lang:language]</span> <span class="string">[url]</span> <span class="string">[link</span> <span class="string">text]</span> <span class="string">[additional</span> <span class="string">options]</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">code</span> <span class="string">snippet</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">endcodeblock</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure><p>　　还有一种就是用反引号的形式(格式问题，不能换行只能放在一行，实际使用将代码和第二个反引号换行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` [language] [title] [url] [link <span class="built_in">text</span>] code snippet```</span><br></pre></td></tr></table></figure><br/><h2 id="Hexo插件"><a href="#Hexo插件" class="headerlink" title="Hexo插件"></a><strong>Hexo插件</strong></h2><h3 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h3><p>　　由于Hexo在生成博客文章链接时，默认是按照年/月/日/标题的格式，这样生成的链接太过冗长，虽然可以在_config.yml中修改”permalink”的格式，但是这样还是无法保证链接的唯一性，而且可能会造成链接的格式混乱。<br>　　而hexo-abbrlink插件可以生成唯一文章链接，而且配置十分简单。先安装该插件，在博客根目录，右键”Git Bush Here”，打开git控制台，然后输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>　　接着在博客根目录下的_config.yml文件中，设置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html/</span>   <span class="comment">#archives的位置可以随意命名，或archives/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure><h3 id="hexo-generator-feed"><a href="#hexo-generator-feed" class="headerlink" title="hexo-generator-feed"></a>hexo-generator-feed</h3><p>　　首先，我们需要了解<strong>什么是RSS</strong>，RSS指Really Simple Syndication(真正简易联合)。RSS是我们有能力聚合网站的内容，它定义了非常简单的方法来共享和查看标题和内容。RSS文件可被自动更新，且允许为不同的网站进行视图的个性化。<br>　　之所以使用RSS，是为了让订阅RSS的用户不必每日来您的网站检查更新，他可以使用RSS聚合器来检查更新。<br>　　先安装hexo-generator-feed，git控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>　　然后在_config.yml文件中在<strong>Extension</strong>位置，添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">icarus</span></span><br><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>　　设置完毕后，你的RSS链接就是<strong>域名/atom.xml</strong>。一般RSS功能在页面上的标志是”wifi信号”</p><h3 id="hexo-lazyload-image"><a href="#hexo-lazyload-image" class="headerlink" title="hexo-lazyload-image"></a>hexo-lazyload-image</h3><p>　　由于图片等静态资源的加载，需要花费较多的时间，因此我们需要优化网站图片加载的速度。图片懒加载是一种常用的方法。hexo-lazyload-image插件会将博客中img标签的src属性替换为一个loading image，把真实的图片地址放在data-origin属性下面，然后当加载到该图片时，它会用一段js将data-origin的内容替换为src，达到懒加载的目的。<br>　　首先，进入博客根目录下安装该插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><p>　　然后在_config.yml配置文件中，添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">onlypost:</span> <span class="literal">false</span>   <span class="comment">#若为true,则只有在post和page中会支持懒加载</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="comment"># eg ./images/loading.gif   #如果不填，使用默认的加载图片，若想自定义，可将相应图片放到文件夹中，并填写相应的路径</span></span><br></pre></td></tr></table></figure><p>eg:<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406221715.png" alt=""></p><h3 id="valine评论插件"><a href="#valine评论插件" class="headerlink" title="valine评论插件"></a>valine评论插件</h3><p>　　由于我使用的icarus主题已经集成了valine评论插件功能，因此只需要在主题文件夹下的_config.yml文件中添加上valine插件的<strong>app_id</strong>和<strong>app_key</strong>即可。获取方法，登录<a href="https://www.leancloud.cn/">LeanCloud官网</a>，注册LeanCloud账号。<br>　　然后创建应用，选择开发版，名称随意，如下：<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406223858.png" alt=""><br>　　接着在<strong>设置</strong>-<strong>应用Keys</strong>中就可以看到你的AppID和AppKey，如下：<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406224031.png" alt=""><br>　　若想管理评论数据，可以在<strong>存储</strong>-<strong>结构化数据</strong>-<strong>Comment</strong>中设置：<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200406224349.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo创建博客(基础篇)</title>
      <link href="/archives/5ec59427.html/"/>
      <url>/archives/5ec59427.html/</url>
      
        <content type="html"><![CDATA[<p>　　这只是个最基础的教程，参考了知乎上“洪卫”dl的文章——“Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)”。<br>　　其他各种自定义配置详见“大佬”的教程（｡ò ∀ ó｡）</p><a id="more"></a><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a><strong>安装Git</strong></h2><p>　　Git作为目前世界上最先进的<strong>分布式版本控制系统</strong>，拥有强大的项目版本管理能力。<del>(ps:不过我暂时还没去深入了解，(lll￢ω￢))</del><br>　　Windows直接到官网下载就行，Linux的话直接一行shell命令解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a><strong>安装Node.js</strong></h2><p>　　因为’Hexo’是基于’Node.js’编写的，所以需要先安装’Node.js’以及包管理工具’npm’<br>　　同样Windows到官网下载，无脑安装即可，Linux还是命令行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>　　前两个工具安装完毕之后，就可以安装’Hexo’了。<br>　　先创建一个文件夹用于存放博客文件，我是放在’D:\Study\MyBlog’下。接着在该目录下右键点击’Git Bash Here’,打开’git’的控制台窗口。输入如下命令全局安装hexo脚手架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>　　安装完成后，可以输入’hexo -v’检查是否安装成功</p><h3 id="Hexo初始化自己的网站"><a href="#Hexo初始化自己的网站" class="headerlink" title="Hexo初始化自己的网站"></a>Hexo初始化自己的网站</h3><p>　　在git控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init BinBlog</span><br></pre></td></tr></table></figure><p>　　初始化自己网站，其中’BinBlog’是我自己命名的博客网站名称，可随意命名</p><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><p>　　进入刚创建的博客目录，安装依赖项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> BinBlog</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>　　安装完毕后，在响应的博客目录下，可以看到如下文件夹：</p><pre><code>-&apos;node_modules&apos;:依赖包-&apos;public&apos;:存放生成的页面，包括html、css、js等-&apos;scaffolds&apos;:生成文章的一些模板，比如草稿md、页面md以及文章md-&apos;source&apos;:存放你写的文章以及你需要自己添加的一些资源文件-&apos;themes&apos;:主题文件，Hexo有多种主题，默认使用的是&apos;landscape&apos;主题-&apos;_config.yml&apos;:博客的配置文件，其中可以配置网站的各种属性，之后再说</code></pre><h3 id="预览默认博客页面"><a href="#预览默认博客页面" class="headerlink" title="预览默认博客页面"></a>预览默认博客页面</h3><p>　　输入’hexo g’生成静态页面，然后输入’hexo s’打开本地服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>　　服务器会开放4000端口，浏览器打开’localhost:4000/‘可以看到默认的博客页面。<br>　　emmmm，不得不说这个默认的页面感觉有点丑，不过不要紧，后续我会提供本网站所使用的主题icarus的教程。</p><h2 id="Github上创建个人仓库"><a href="#Github上创建个人仓库" class="headerlink" title="Github上创建个人仓库"></a><strong>Github上创建个人仓库</strong></h2><p>　　在如图1位置’New repository’，新建个人仓库<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403205753.png" alt="图1"><br>　　然后在’Repository name’字段处填自己的github账号名称+’github.io’，这样当部署到’yourname.github.io’网址时，才会识别到你的仓库，另外在初始化时附带上README。如图2所示<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403205958.png" alt="图2"></p><h2 id="生成SSH并添加到Github"><a href="#生成SSH并添加到Github" class="headerlink" title="生成SSH并添加到Github"></a><strong>生成SSH并添加到Github</strong></h2><p>　　在git控制台输入如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>　　全局设置到指定的Git仓库。网上给的设置邮箱的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global At-Cost Domain Pricing - Domain Cost Club <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>　　但是我输入之后提示错误信息…<br>　　接着创建’SSH’，学过信息安全的应该都知道。说白了就是通过公私钥匹配，将你的文件上传到’GitHub’上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>　　然后一般在你的’C:\Users\xxx&#39;目录下，会生成’.ssh’文件夹，里面有你的私钥和公钥。可能我之前生成过ssh，已经有了该目录，就不演示了。<br>　　接着将生成的公钥’id_rsa.pub’的内容复制到你的github上，如图3所示。<br><img src="https://gitee.com/zhangyaobin123/cdn/raw/master/img/20200403210234.png" alt="图3"><br>　　即在setting中的’SSH and GPG keys’中’New SSH key’，给其取个名字，然后将复制的公钥粘贴到此处。<br>　　在git控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>　　若出现你的用户名，即配置成功</p><h2 id="将hexo部署到GitHub上"><a href="#将hexo部署到GitHub上" class="headerlink" title="将hexo部署到GitHub上"></a><strong>将hexo部署到GitHub上</strong></h2><p>　　接着我们就可以将hexo生成的网页托管到GitHub上。</p><h3 id="修改’-config-yml’文件"><a href="#修改’-config-yml’文件" class="headerlink" title="修改’_config.yml’文件"></a>修改’_config.yml’文件</h3><p>　　打开博客根目录下的’_config.yml’配置文件，修改最后一行的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/hanabiicros/hanabiicros.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>　　‘repository’的位置填写自己的github地址即可。这样通过git命令上传的文件就会放到你的仓库中</p><h3 id="安装deploy-git"><a href="#安装deploy-git" class="headerlink" title="安装deploy-git"></a>安装deploy-git</h3><p>　　需要先安装部署的命令，才能用’git d’上传到’GitHub’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>　　然后执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>　　‘hexo c’即清除命令，这个命令还是挺好用的，如果你遇到一般的小bug，那就’hexo c’然后再执行。’hexo g’即生成静态网页，’hexo d’部署文章。若提示’Deploy done:git’即操作成功。之后就能在’yourname.github.io’网站上看到你的博客。</p><h2 id="写文章并发布"><a href="#写文章并发布" class="headerlink" title="写文章并发布"></a><strong>写文章并发布</strong></h2><p>　　完成了上述基本步骤之后，你如果就用默认的主题的话，那么你就可以开始撰写你的第一个’纯文本’博客了。之所以说是’纯文本’，是因为还有许多hexo插件没有介绍。具体内容将放在下一篇进行具体说明。<br>　　现在你需要做的就是在博客的根目录下输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">"arctile title"</span></span><br></pre></td></tr></table></figure><p>　　新建一篇文章，然后在博客根目录下的’source_posts’的目录下多了一个’xxx.md’的文件，这就是你刚刚创建的。接着就可以进入’vscode’中编辑’markdown’文件了。编写完后执行固定的这三个命令’hexo c’、’hexo g’、’hexo d’。你也可以在提交前先进行本地预览，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>　　到这里一个最基本的博客就搭建完毕了。下一篇会对里面的具体配置内容进行相关介绍，并进行个性化定制！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
